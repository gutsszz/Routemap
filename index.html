    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Travel Route Planner</title>
      <!-- Preloading Fonts -->
<link rel="preload" href="fonts/KunstlerScript.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="fonts/Rockwell.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="fonts/Magneto.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="fonts/AerioViasBrasilNF.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="fonts/Cormier.woff" as="font" type="font/woff" crossorigin="anonymous">
<link rel="preload" href="fonts/HausSans.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="fonts/MagnoliaScript.ttf" as="font" type="font/ttf" crossorigin="anonymous">

      <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400&display=swap" rel="stylesheet">
      <link href="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.css" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Oswald:wght@400;700&family=Yellowtail&family=Bangers&family=Fugaz+One&family=Racing+Sans+One&family=Parisienne&family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
      
      <script src="https://cdn.tailwindcss.com"></script>
      <style>

@font-face {
        font-family: 'Kunstler Script';
        src: url('fonts/KunstlerScript.woff2') format('woff2');
    }
    @font-face {
        font-family: 'Rockwell';
        src: url('fonts/Rockwell.woff2') format('woff2');
    }
    @font-face {
        font-family: 'Magneto';
        src: url('fonts/Magneto.ttf') format('truetype');
    }
    @font-face {
        font-family: 'Aerio Vias Brasil NF';
        src: url('fonts/AerioViasBrasilNF.ttf') format('truetype');
    }
    @font-face {
        font-family: 'Cormier';
        src: url('fonts/Cormier.woff') format('woff');
    }
    @font-face {
        font-family: 'Haus Sans';
        src: url('fonts/HausSans.ttf') format('truetype');
    }
    @font-face {
        font-family: 'Magnolia Script';
        src: url('fonts/MagnoliaScript.ttf') format('truetype');
    }
        .transition-transform {
          transition: transform 0.3s ease;
        }
        .dropdown-text {
          font-family: 'Lora', sans-serif;
          font-size: 14px;
        }
        .arrow {
          font-family: 'Lora', Arial, sans-serif; /* Add fallbacks */

          transition: transform 0.3s ease;
        }
        .arrow-down {
          transform: rotate(90deg);
        }
        

        /* Custom scrollbar styles */
    ::-webkit-scrollbar {
      width: 6px; /* Reduced width */
    }

    ::-webkit-scrollbar-track {
      background: #f1f1f1; /* Light gray track */
      border-radius: 10px; /* Rounded corners */
    }

    ::-webkit-scrollbar-thumb {
      background: #cca385; /* Light brown thumb */
      border-radius: 10px; /* Rounded corners */
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #b59c74; /* Darker shade on hover */
    }



     /* Mobile styles */
@media (max-width: 768px) {
  /* Center preview container */
  #previewContainer {
    display: block;
    width: 90vw;
    height: 70vw;
    top: 50%;
    left: 5%;
    z-index: 10;
  }

  #previewMap {
    width: 100%;
    height: 100%;
    position: relative;
  }

  #mapCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  #mapWrapper {
    display: none;
  }

  #sidebar {
    height: 100%;
    overflow-y: auto;
    width: 100%;
    
  }

  #previewContainer {
  touch-action: none; /* Disable touch gestures while dragging */
  cursor: grab;
}

#previewContainer.dragging {
  cursor: grabbing;
}


/* Highlight border of the Preview Container */
#previewContainer {
  border-width: 2px;
  border-color: #cca385;
  border-radius: 6px;
}
/* Minimize button smaller and more user-friendly */
/* Minimize Button */
#minimizePreview {
  width: 16px;
  height: 16px;
  font-size: 8px;
  line-height: 8px;
  text-align: center;
  border: none;
  cursor: pointer;
  background-color: #cca385;
  color: white;
  border-radius: 50%;
  position: absolute;
  top: 1px;
  right: 1px;
  z-index: 10;
}


/* Preview Toggle Button */
#previewToggleButton {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  cursor: pointer;
  background-color: #f9f9f9;
  border-radius: 10px;
  font-size: 16px;
  font-weight: bold;
  color: #333;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

#previewToggleButton:hover {
  background-color: #e0e0e0;
  border-color: #999;
}


}

      </style>
    </head>
    <body class="bg-gray-200">

      <!-- Top Bar -->
      <div class="w-full bg-white h-16 flex items-center justify-between px-4 shadow-lg z-10 fixed top-0">
        <button id="toggleSidebar" class="text-[#cca385] text-2xl">&#9776;</button>
        <div class="text-2xl font-semibold text-[#cca385]">Route Map</div>
      </div>

      <!-- Main Content -->
      <div class="flex pt-16 h-screen">
        
        <!-- Sliding Bar -->
        <div id="sidebar" class="w-80 h-screen bg-white shadow-md p-4  fixed z-20">
          
          
          <!-- Dropdown Menus -->
          <div class="space-y-4">
            <div class="dropdown border-b border-gray-200">
              <button class="w-full text-left bg-[#f9f9f9] p-3 rounded-lg hover:bg-[#e5e5e5] focus:outline-none flex items-center dropdown-text" onclick="toggleDropdown('dropdown1', this)">
                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 w-5 h-5 text-[#cca385] arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>                 Places
              </button>
              <div id="dropdown1" class="hidden pl-4">
                <div class="relative mb-4 mt-2">
                  <input id="geocoder-input" 
                         class="w-full p-2 bg-white text-black border border-gray-300 rounded-md focus:border-[#cca385]" 
                         type="text" 
                         placeholder="Search for a place..." 
                         oninput="performGeocoding(this.value)" />
                  <!-- Geocoding results dropdown -->
                  <div id="geocoder-results" 
                       class="absolute w-full bg-white text-black rounded-md border border-gray-300 mt-1 z-10 hidden">
                  </div>
                </div>
        
                <!-- Scrollable container for inputs -->
                <div id="locationsContainer" class="flex flex-col space-y-2 max-h-40 overflow-y-auto mt-2 pr-2">

                  <!-- First input row -->
                 
                </div>
                <!-- Add button below inputs -->
                <div class="flex flex-col space-y-4 my-6">
                  <!-- Add and Clear All Buttons -->
                  <div class="flex justify-center space-x-4">
                      <button onclick="addLocation()" class="bg-[#cca385] text-white px-6 py-1 rounded w-full">Add</button>
                      <button onclick="clearAll()" class="bg-[#cca385] text-white px-6 py-1 rounded w-full">Clear All</button>
                  </div>
              
                  <!-- Route Button -->
                  <div class="flex justify-center">
                      <button onclick="calculateRoute()" class="bg-[#cca385] text-white px-6 py-1 rounded w-full">Route</button>
                  </div>
                  
              </div>
              
                
              </div>
            </div>



            <div class="dropdown border-b border-gray-200">
              <button class="w-full text-left bg-[#f9f9f9] p-3 rounded-lg hover:bg-[#e5e5e5] focus:outline-none flex items-center dropdown-text" onclick="toggleDropdown('dropdown2', this)">
                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 w-5 h-5 text-[#cca385] arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>                 Theme
              </button>
              <div id="dropdown2" class="hidden pl-4">
                <div class="flex space-x-4 mt-2 mb-4">
                  <div class="w-12 h-12 bg-blue-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('blue')">
                    <div class="w-6 h-6 bg-blue-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-green-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('green')">
                    <div class="w-6 h-6 bg-green-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-red-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('red')">
                    <div class="w-6 h-6 bg-red-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-yellow-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('yellow')">
                    <div class="w-6 h-6 bg-yellow-700 rounded-full"></div>
                  </div>
                </div>
                <div class="flex space-x-4 mb-4">
                  <div class="w-12 h-12 bg-purple-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('purple')">
                    <div class="w-6 h-6 bg-purple-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-orange-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('orange')">
                    <div class="w-6 h-6 bg-orange-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-pink-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('pink')">
                    <div class="w-6 h-6 bg-pink-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-gray-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('gray');">
                    <div class="w-6 h-6 bg-gray-700 rounded-full"></div>
                  </div>
                </div>
                
                
                <!-- Color Options Section -->
<div id="customThemeDropdown" class=" pl-4 mt-2">
  <!-- Row 1 -->
  <div class="flex space-x-4 mb-4">
    <!-- Land Color -->
    <div class="w-full">
      <p class="dropdown-text text-gray-600">Land Color:</p>
      <div class="flex mt-1">
        <input type="color" id="landColor" class="w-8 h-8  border rounded" onchange="updateLandColor(this.value)">
      </div>
    </div>
    <!-- Water Color -->
    <div class="w-full">
      <p class="dropdown-text text-gray-600">Water Color:</p>
      <div class="flex mt-1">
        <input type="color" id="waterColor" class="w-8 h-8  border rounded" onchange="updateWaterColor(this.value)">
      </div>
    </div>
  </div>

  <!-- Row 2 -->
  <div class="flex space-x-4 mb-4">
    <!-- Route Color -->
    <div class="w-full">
      <p class="dropdown-text text-gray-600">Route Color:</p>
      <div class="flex mt-1">
        <input type="color" id="routeColor" class="w-8 h-8  border rounded" onchange="updateRouteColor(this.value)">
      </div>
    </div>
    <!-- Marker Color -->
    <div class="w-full">
      <p class="dropdown-text text-gray-600">Marker Color:</p>
      <div class="flex mt-1">
        <input type="color" id="markerColor" class="w-8 h-8  border rounded" onchange="updateMarkerColor(this.value)">
      </div>
    </div>
  </div>
</div>


              </div>
            </div>
            

            <div class="dropdown border-b border-gray-200">
              <button class="w-full text-left bg-[#f9f9f9] p-3 rounded-lg hover:bg-[#e5e5e5] focus:outline-none flex items-center dropdown-text" onclick="toggleDropdown('dropdown3', this)">
                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 w-5 h-5 text-[#cca385] arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>                 
                Text 
              </button>
              
              <div id="dropdown3" class="hidden pl-4 pr-2 overflow-y-auto" style="max-height: 300px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);"> <!-- Added styles for better appearance -->
                
                <!-- Alignment Option Dropdown -->
                <div class="flex items-center mt-4 mb-3">
                  <label for="alignmentOption" class="dropdown-text text-gray-600 mr-3">Alignment:</label>
                  <select id="alignmentOption" class="border p-2 rounded-lg text-gray-700" onchange="updateAlignmentOption(this.value)">
                    <option value="right">Right</option>
                    <option value="center">Center</option>
                    <option value="left">Left</option>
                  </select>
                </div>
                
                <!-- Font Style Option Dropdown -->
                <div class="flex items-center mt-4 mb-3">
                  <label for="fontStyleOption" class="dropdown-text text-gray-600 mr-3">Font Style:</label>
                  <select id="fontStyleOption" class="border p-2 rounded-lg text-gray-700" onchange="updateFontStyleOption(this.value)">
                    <option value="normal">Normal</option>
                    <option value="italic">Italic</option>
                  </select>
                </div>
                
<!-- Font Family Option Dropdown -->
<div class="flex flex-col sm:flex-row items-start sm:items-center mt-4 mb-3">
  <label for="fontFamilyOption" class="dropdown-text text-gray-600 mb-2 sm:mb-0 sm:mr-3">Font Family:</label>
  <div class="relative w-full sm:w-auto">
    <select id="fontFamilyOption" 
            class="border p-2 rounded-lg text-gray-700 w-full sm:w-auto max-h-40 overflow-y-auto focus:outline-none focus:ring-2 focus:ring-blue-500" 
            onchange="updateFontFamilyOption(this.value)">
      <!-- Alphabetically Sorted Options -->
      <option value="Aerio Vias Brasil NF">Aerio Vias Brasil NF</option>
      <option value="Arial">Arial</option>
      <option value="Bangers">Bangers</option>
      <option value="Cormier">Cormier</option>
      <option value="Courier New">Courier New</option>
      <option value="Dancing Script">Dancing Script</option>
      <option value="Fugaz One">Fugaz One</option>
      <option value="Haus Sans">Haus Sans</option>
      <option value="Helvetica">Helvetica</option>
      <option value="Kunstler Script">Kunstler Script</option>
      <option value="Magneto">Magneto</option>
      <option value="Magnolia Script">Magnolia Script</option>
      <option value="Oswald">Oswald</option>
      <option value="Parisienne">Parisienne</option>
      <option value="Permanent Marker">Permanent Marker</option>
      <option value="Racing Sans One">Racing Sans One</option>
      <option value="Rockwell">Rockwell</option>
      <option value="Tahoma">Tahoma</option>
      <option value="Times New Roman">Times New Roman</option>
      <option value="Verdana">Verdana</option>
      <option value="Yellowtail">Yellowtail</option>
    </select>
  </div>
</div>
            
                <!-- Existing Text Color Picker and Hide Text Switch -->
                <div class="w-full flex items-center justify-between mt-4 mb-3">
                  <div class="flex items-center">
                    <p class="dropdown-text text-gray-600 mr-3">Text Color:</p>
                    <input type="color" id="textColor" class="w-8 h-8 border rounded" onchange="updateTextColor(this.value)">
                  </div>
                  <div class="flex items-center">
                    <label for="toggleCityNames" class="dropdown-text mr-3 text-gray-700">Hide Text</label>
                    <div class="relative">
                      <input type="checkbox" id="toggleCityNames" class="peer appearance-none w-10 h-5 bg-gray-300 rounded-full cursor-pointer transition duration-200 focus:outline-none checked:bg-[#cca385]" />
                      <span class="absolute left-1 top-0.5 w-4 h-4 bg-white rounded-full transition-transform duration-200 ease-in-out transform peer-checked:translate-x-4 pointer-events-none"></span>
                    </div>
                  </div>
                </div>
            
                <!-- Title Input Box -->
                <div class="mt-2 mb-4">
                  <label for="titleInput" class="dropdown-text text-gray-600">Title:</label>
                  <input type="text" id="titleInput" placeholder="Enter a title" class="border p-2 rounded w-full mt-1">
                </div>
            
                <!-- Text Message Box -->
                <div class="mt-4 mb-4">
                  <label for="messageInput" class="dropdown-text text-gray-600">Text:</label>
                  <textarea id="messageInput" placeholder="Enter your text" class="border p-2 rounded w-full mt-1" rows="4"></textarea>
                </div>
            
                <!-- Sub-Text Message Box -->
                <div class="mt-4 mb-4">
                  <label for="subTextInput" class="dropdown-text text-gray-600">Sub-Text:</label>
                  <textarea id="subTextInput" placeholder="Enter your sub-text" class="border p-2 rounded w-full mt-1" rows="3"></textarea>
                </div>
              </div>
            </div>
                          
            <div class="dropdown">
              <button class="w-full text-left bg-[#f9f9f9] p-3 rounded-lg hover:bg-[#e5e5e5] focus:outline-none flex items-center dropdown-text" onclick="toggleDropdown('dropdown4', this)">
                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 w-5 h-5 text-[#cca385] arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
                Size
              </button>
              <div id="dropdown4" class="hidden pl-4 mt-2">

                <!-- Orientation Switch -->
                <div class="flex items-center justify-between mb-4">
                    <span class="text-gray-600">Orientation:</span>
                    <button id="orientationButton" 
                            class="w-32 h-10 bg-gray-200 border rounded-lg flex items-center justify-center hover:bg-gray-300 focus:bg-gray-300 focus:outline-none" 
                            onclick="switchOrientation()">
                        Landscape
                    </button>
                </div>
            
                <!-- Size Selection Boxes -->
                <div class="mt-4 flex space-x-4" id="sizeSelector">
                    <button 
                        class="w-24 h-16 bg-gray-200 border rounded-lg flex items-center justify-center hover:bg-gray-300 focus:bg-gray-300 focus:outline-none" 
                        onclick="setSize('size24x18', this)">
                        24x18
                    </button>
                    <button 
                        class="w-24 h-16 bg-gray-200 border rounded-lg flex items-center justify-center hover:bg-gray-300 focus:bg-gray-300 focus:outline-none" 
                        onclick="setSize('size18x12', this)">
                        18x12
                    </button>
                    <button 
                        class="w-24 h-16 bg-gray-200 border rounded-lg flex items-center justify-center hover:bg-gray-300 focus:bg-gray-300 focus:outline-none" 
                        onclick="setSize('size8_5x11', this)">
                        11x8.5
                    </button>
                </div>
            
                <!-- Hidden inputs to store values -->
                <input type="hidden" id="selectedSize" value="size24x18"> <!-- Default value -->
            
                <!-- Hidden Inputs for DPI, Width, Height -->
                <div class="hidden">
                    <label for="widthInput">Width (inches):</label>
                    <input type="number" id="widthInput" value="8" step="0.1">
                    <label for="heightInput">Height (inches):</label>
                    <input type="number" id="heightInput" value="6" step="0.1">
                    <label for="dpiInput">DPI:</label>
                    <input type="number" id="dpiInput" value="300">
                </div>
            
                <!-- Output Format Dropdown -->
                <div class="mt-4">
                    <label for="outputOptions" class="block text-gray-600">Output format:</label>
                    <select id="outputOptions" class="p-2 border rounded w-full focus:outline-none">
                        <option value="png">PNG</option>
                        <option value="pdf">PDF</option>
                    </select>
                </div>
                <div class="flex justify-center space-x-4 my-6">
                    <button id="generate-btn" class="bg-[#cca385] text-white px-6 py-1 rounded w-full">Print</button>
                </div>
            
            </div>
            
            </div>
            



          </div>
        </div>
        <div id="mapWrapper" class="flex-1 bg-gray-200 ml-64 relative">
          <div id="mapContainer" class="absolute top-0 bottom-0 left-0 right-0 m-auto" style="width: 60%; aspect-ratio: 4 / 3; background-color: white; box-shadow: 0px 4px 15px rgba(0, 0, 0, 0.2); z-index: 10;">
            <div id="map" class="flex items-center justify-center w-full h-full text-gray-500">
              <!-- Map will appear here -->
            </div>
            <!-- Canvas overlay -->
            <canvas id="mapCanvas" class="absolute top-0 left-0 w-full h-full" style="pointer-events: none;"></canvas>
          </div>
        </div>
        <div id="previewContainer" class=" hidden bg-white fixed p-4 shadow-xl border" style="z-index: 50;">
          <button id="minimizePreview" onclick="togglePreviewContainer()">âˆ’</button>
          <!-- Semi-transparent background -->
          <div class="absolute inset-0 bg-white opacity-80"></div>
          <!-- Map content above the background -->
          <div id="previewMap" class="relative flex items-center justify-center w-full h-full text-gray-500"></div>
        </div>
        
        <!-- Vertical Preview Toggle Button -->
        <button id="previewToggleButton" 
                onclick="togglePreviewContainer()" 
                style="display: none; position: fixed; right: 1px; top: 50%; transform: translateY(-50%); width: 30px; height: 120px; background: #f1f1f1; border: 1px solid #ccc; text-align: center; cursor: pointer; z-index: 100;">
          Preview
        </button>
        
        

    <script>



const toggleSidebar = document.getElementById('toggleSidebar');
    const sidebar = document.getElementById('sidebar');

    toggleSidebar.addEventListener('click', () => {
      sidebar.classList.toggle('-translate-x-full');
    });

    // Function to toggle dropdowns
    function toggleDropdown(dropdownId, button) {
      const dropdown = document.getElementById(dropdownId);
      const arrow = button.querySelector('.arrow');
      dropdown.classList.toggle('hidden');
      arrow.classList.toggle('arrow-down');
    }


      mapboxgl.accessToken = 'pk.eyJ1Ijoic3RvcnlvcCIsImEiOiJjbTMwNzVwZXEwbGlsMmxzamp2d2l3ZTFmIn0.4Z_RR1VXQVZyvFHEb_jsMw';
          let mapContainer = document.getElementById('mapContainer');
          let mapElement = document.getElementById('map');
          let previewContainer = document.getElementById('previewContainer');
          let previewMapElement = document.getElementById('previewMap');
  
      const map = new mapboxgl.Map({
      container: 'map',
  
      style: 'mapbox://styles/storyop/cm307fkwg009i01qtd7rkg9hr',
      zoom: 1.2,
      center: [-145, 30],
      preserveDrawingBuffer: true,
  
      });

  
  
      function moveMapToPreview() {
    if (window.innerWidth <= 768) {
        // Move map and canvas to preview container
        if (!previewMapElement.contains(mapElement)) {
            previewMapElement.appendChild(mapElement);
            const canvas = document.getElementById('mapCanvas');
            previewContainer.appendChild(canvas); // Attach canvas to preview
            map.resize(); // Resize map for smaller container
        }
    } else {
        // Move map and canvas back to the main container
        if (!mapContainer.contains(mapElement)) {
            mapContainer.appendChild(mapElement);
            const canvas = document.getElementById('mapCanvas');
            mapContainer.appendChild(canvas); // Attach canvas back to main map container
            map.resize(); // Resize map for larger container
        }
    }
}

  
          // Call the function initially
          moveMapToPreview();
  
          // Adjust on window resize
          window.addEventListener('resize', moveMapToPreview);
          let isDragging = false;
let offsetX, offsetY;
let dragStartedOutsideMap = false;

// Target the container and map

// Mouse/touch down event
previewContainer.addEventListener('mousedown', startDrag);
previewContainer.addEventListener('touchstart', startDrag, { passive: false });

// Mouse/touch move event
document.addEventListener('mousemove', drag);
document.addEventListener('touchmove', drag, { passive: false });

// Mouse/touch up event
document.addEventListener('mouseup', stopDrag);
document.addEventListener('touchend', stopDrag);

function startDrag(event) {
  // Check if the drag starts outside the map area
  const target = event.target;
  dragStartedOutsideMap = !mapElement.contains(target);

  if (dragStartedOutsideMap) {
    isDragging = true;
    previewContainer.classList.add('dragging');

    // Calculate offset
    const rect = previewContainer.getBoundingClientRect();
    if (event.type === 'mousedown') {
      offsetX = event.clientX - rect.left;
      offsetY = event.clientY - rect.top;
    } else if (event.type === 'touchstart') {
      const touch = event.touches[0];
      offsetX = touch.clientX - rect.left;
      offsetY = touch.clientY - rect.top;
    }
  }
}

function drag(event) {
  if (!isDragging || !dragStartedOutsideMap) return;

  // Prevent default scrolling behavior
  event.preventDefault();

  let clientX, clientY;

  if (event.type === 'mousemove') {
    clientX = event.clientX;
    clientY = event.clientY;
  } else if (event.type === 'touchmove') {
    const touch = event.touches[0];
    clientX = touch.clientX;
    clientY = touch.clientY;
  }

  // Calculate new position
  const newX = Math.min(window.innerWidth - previewContainer.offsetWidth, Math.max(0, clientX - offsetX));
  const newY = Math.min(window.innerHeight - previewContainer.offsetHeight, Math.max(0, clientY - offsetY));

  // Move the container
  previewContainer.style.left = `${newX}px`;
  previewContainer.style.top = `${newY}px`;
}

function stopDrag() {
  isDragging = false;
  dragStartedOutsideMap = false;
  previewContainer.classList.remove('dragging');
}


// Variables to track preview state
let isPreviewVisible = true;

// Function to toggle the visibility of the preview container
function togglePreviewContainer() {
  const previewContainer = document.getElementById('previewContainer');
  const previewButton = document.getElementById('previewToggleButton');
  if (window.innerWidth <= 768) {

  if (isPreviewVisible) {
    // Hide the preview container and show the toggle button
    previewContainer.style.display = 'none';
    previewButton.style.display = 'block';
    isPreviewVisible = false;
  } else {
    // Show the preview container and hide the toggle button
    previewContainer.style.display = 'block';
    previewButton.style.display = 'none';
    isPreviewVisible = true;
  }
}else { previewContainer.style.display = 'none';
previewButton.style.display = 'none'}

}


         // Function to toggle dropdowns
  function toggleDropdown(dropdownId, button) {
    const dropdowns = document.querySelectorAll('.dropdown > div');
    const arrows = document.querySelectorAll('.arrow');
  
    // Close all other dropdowns
    dropdowns.forEach((dropdown) => {
      if (dropdown.id !== dropdownId) {
        dropdown.classList.add('hidden'); // Close other dropdowns
      }
    });
  
    // Reset all arrows
    arrows.forEach((arrow) => {
      if (!dropdownId.includes(arrow.closest('.dropdown').querySelector('div').id)) {
        arrow.classList.remove('arrow-down'); // Reset other arrows
      }
    });
  
    // Toggle the clicked dropdown and arrow
    const dropdown = document.getElementById(dropdownId);
    const arrow = button.querySelector('.arrow');
    dropdown.classList.toggle('hidden');
    arrow.classList.toggle('arrow-down');

  }

// Function to set default values
function setDefaultValues() {
    // Set default values for the input fields
    document.getElementById('titleInput').value = 'Title';
    document.getElementById('messageInput').value = 'Message';
    document.getElementById('subTextInput').value = 'Subtext';
}

// Call the function when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', setDefaultValues);




let selectedSizeButton = null; // Variable to keep track of the selected button
let printsize = "size24x18";   // Default print size
let orientation = "landscape"; // Default orientation

// Function to handle size selection
function setSize(size, button) {
    // Update the hidden input with the selected size value (e.g., size24x18 or size18x12)
    document.getElementById('selectedSize').value = size;
    printsize = size;

    // If a button was already selected, remove the special border class
    if (selectedSizeButton) {
        selectedSizeButton.classList.remove('border-[#cca385]', 'border-4');
    }

    // Add the special border to the newly selected button
    button.classList.add('border-[#cca385]', 'border-4');

    // Keep track of the selected button
    selectedSizeButton = button;
}

// Function to switch orientation
function switchOrientation() {
    // Toggle orientation value
    orientation = orientation === "landscape" ? "portrait" : "landscape";

    // Update the orientation button text
    document.getElementById("orientationButton").innerText = 
        orientation.charAt(0).toUpperCase() + orientation.slice(1);

    // Update size button labels dynamically
    const sizeSelector = document.getElementById("sizeSelector").children;
    for (let button of sizeSelector) {
        // Parse the current button's dimensions
        const dimensions = button.innerText.split("x");
        if (dimensions.length === 2) {
            const width = dimensions[0];
            const height = dimensions[1];

            // Swap dimensions based on the current orientation
            button.innerText = orientation === "landscape" ? `${Math.max(width, height)}x${Math.min(width, height)}` : `${Math.min(width, height)}x${Math.max(width, height)}`;
        }
    }

    // Adjust the hidden inputs for width and height dynamically
    const widthInput = document.getElementById("widthInput");
    const heightInput = document.getElementById("heightInput");

    // Swap values based on orientation
    const temp = widthInput.value;
    widthInput.value = heightInput.value;
    heightInput.value = temp;
}


  function removeLocation(element) {
    const locationsContainer = document.getElementById('locationsContainer');
    const locationRows = locationsContainer.querySelectorAll('div');

    const indexToRemove = Array.from(locationRows).indexOf(element.parentElement);

    if (locationRows.length > 1) {
        // Remove the corresponding marker from the map
        if (markers[indexToRemove]) {
            markers[indexToRemove].remove(); // Remove marker from the map
            markers.splice(indexToRemove, 1); // Remove marker from the markers array
        }

        // Remove the point from GeoJSON data
        geojsonData.features.splice(indexToRemove, 1); // Remove the feature from the GeoJSON

        // Update the GeoJSON source on the map
        if (map.getSource('markers')) {
            map.getSource('markers').setData(geojsonData); // Refresh the source data with the updated GeoJSON
        }

        // Remove the location container from the DOM
        element.parentElement.remove();
        updateIndexes(); // Update the index numbers for the remaining locations
    } else if (locationRows.length === 1) {
        // Clear the last remaining container, but don't remove it
        const inputField = locationRows[0].querySelector('input');
        inputField.value = ''; // Clear the input field

        // Remove the marker if it exists
        if (markers[0]) {
            markers[0].remove(); // Remove marker from the map
            markers = []; // Clear the markers array since no markers are left
        }

        // Clear stored coordinates from the dataset
        locationRows[0].removeAttribute('data-lat');
        locationRows[0].removeAttribute('data-lng');

        // Clear the GeoJSON features array
        geojsonData.features = [];

        // Update the GeoJSON source on the map
        if (map.getSource('markers')) {
            map.getSource('markers').setData(geojsonData); // Refresh the source data with the cleared GeoJSON
        }
    }

    // Remove the route line if it exists
    if (map.getSource('route')) {
        map.removeLayer('route');
        map.removeSource('route');
    }

    // Remove any straight lines that were added (tracked in the straightLineLayers array)
    straightLineLayers.forEach(layerId => {
        if (map.getSource(layerId)) {
            map.removeLayer(layerId);
            map.removeSource(layerId);
        }
    });

    // Clear the straight line layers array after removal
    straightLineLayers = [];

    // Recalculate the route only if there are enough remaining points
    // const remainingCoordinates = Array.from(document.querySelectorAll('#locationsContainer > div'))
    //     .filter(row => row.dataset.lat && row.dataset.lng);

    // if (remainingCoordinates.length >= 2) {
    //     calculateRoute();
    // }

    // Update the canvas text after location removal
    updateCityNames();
}
// Helper function to get pairs of consecutive locations
function getLocationPairs() {
    const coordinates = [];
    document.querySelectorAll('#locationsContainer > div').forEach(location => {
        const lat = location.dataset.lat;
        const lng = location.dataset.lng;
        if (lat && lng) {
            coordinates.push([parseFloat(lng), parseFloat(lat)]);
        }
    });

    const pairs = [];
    for (let i = 0; i < coordinates.length - 1; i++) {
        pairs.push([coordinates[i], coordinates[i + 1]]);
    }

    return pairs;
}





// Function to update indexes after adding/removing locations
function updateIndexes() {
    const locationRows = document.querySelectorAll('#locationsContainer > div');
    locationRows.forEach((row, index) => {
        row.querySelector('.dropdown-text').textContent = `${index + 1}.`; // Update the index number
    });
}

        
    // Function to add a new location input
    function addLocation() {
    const locationsContainer = document.getElementById('locationsContainer');
    const locationCount = locationsContainer.querySelectorAll('div').length + 1;

    const newLocation = document.createElement('div');
    newLocation.className = 'flex items-center space-x-2';

    newLocation.innerHTML = `
        <span class="dropdown-text">${locationCount}.</span>
        <input type="text" placeholder="Enter City's name" class="border p-2 rounded w-full"> 
        <span class="remove-btn" onclick="removeLocation(this)">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-black cursor-pointer" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </span>
    `;

    locationsContainer.appendChild(newLocation);
    updateIndexes();

    // Add event listener for the new input field
    const newInputField = newLocation.querySelector('input');
    newInputField.addEventListener('input', updateCityNames); // Attach listener here

    // Scroll to the bottom of the container
    locationsContainer.scrollTop = locationsContainer.scrollHeight;
}


addLocation();




function clearAll() {
    // Clear markers
    if (markers.length > 0) {
        markers.forEach(marker => marker.remove()); // Remove all markers from the map
        markers = []; // Reset the markers array
    }

    // Clear locations in the UI
    const locationsContainer = document.getElementById('locationsContainer');
    locationsContainer.innerHTML = ''; // Clear all location inputs

    // Reset GeoJSON data
    geojsonData.features = [];

    // Update the markers GeoJSON source if it exists
    if (map.getSource('markers')) {
        map.getSource('markers').setData(geojsonData);
    }

    // Clear the route layer and source
    if (map.getSource('route')) {
        map.removeLayer('route');
        map.removeSource('route');
    }

    // Clear all straight-line layers
    straightLineLayers.forEach(layerId => {
        if (map.getSource(layerId)) {
            map.removeLayer(layerId);
            map.removeSource(layerId);
        }
    });
    straightLineLayers = []; // Reset the straight-line layers array

    // Reset any other related UI components or state
    updateCityNames(); // Update canvas text (if applicable)
     map.resize(); // Refresh map rendering
     addLocation();
  }







let currentRouteData = null; // To store route data
let currentStraightLines = []; // To store straight line data

function selectTheme(theme) {
    if (theme == selectedTheme) return;
    selectedTheme = theme; // Update the global theme selection

    // Save the current route and straight lines data (if they exist) before changing the theme
    if (map.getSource('route')) {
        currentRouteData = map.getSource('route')._data; // Save the current route GeoJSON data
    }
    currentStraightLines = straightLineLayers.map(layerId => {
        if (map.getSource(layerId)) {
            return {
                id: layerId,
                data: map.getSource(layerId)._data
            };
        }
        return null;
    }).filter(Boolean); // Remove any null values (in case a source was removed)

    // Update map style based on the selected theme
    const styles = {
        blue: 'mapbox://styles/storyop/cm307fkwg009i01qtd7rkg9hr',
        green: 'mapbox://styles/storyop/cm307et22009o01qz9h1rg977',
        red: 'mapbox://styles/storyop/cm307c1cz00gu01pq3rt22tn4',
        yellow: 'mapbox://styles/storyop/cm307ecg2009h01qt6hc3f6au',
        purple: 'mapbox://styles/storyop/cm307e0pr00to01pigtnu8stc',
        orange: 'mapbox://styles/storyop/cm307djwq00vb01o0bwk6d513',
        pink: 'mapbox://styles/storyop/cm307fwkc00vc01o0amqu3sb0',
        gray: 'mapbox://styles/storyop/cm307f1p8009p01qzekqe7w8i'
    };

    if (styles[theme]) {
        map.setStyle(styles[theme]); // Change the map style
    }

    map.on('style.load', () => {
        // Re-add the route to the map after the style is reloaded
        if (currentRouteData) {
            map.addSource('route', {
                type: 'geojson',
                data: currentRouteData // Use the stored route data
            });

            map.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': routeColors[selectedTheme], // Dynamic route color based on theme
                    'line-width': 4
                }
            });
        }

        // Re-add the straight lines (failed segments) to the map
        currentStraightLines.forEach(line => {
            map.addSource(line.id, {
                type: 'geojson',
                data: line.data
            });

            map.addLayer({
                id: line.id,
                type: 'line',
                source: line.id,
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': routeColors[selectedTheme], // Same color as the route
                    'line-width': 4
                }
            });
        });

        // Re-add the circle layer to display the markers
        if (!map.getSource('markers')) {
            map.addSource('markers', {
                type: 'geojson',
                data: geojsonData // Initially empty or your existing data
            });
        }

        if (!map.getLayer('circle-markers')) {
            map.addLayer({
                id: 'circle-markers',
                type: 'circle',
                source: 'markers',
                paint: {
                    'circle-radius': 6, // Size of the circle
                    'circle-color': '#ffffff', // White background
                    'circle-stroke-color': themeColors[selectedTheme], // Border color from theme
                    'circle-stroke-width': 2, // Border width
                }
            });
        }
    });

    displaytext ();

    // Update UI: Remove selected class from all containers
    const containers = document.querySelectorAll('.theme-container');
    containers.forEach(container => {
        container.classList.remove('border-[#cca385]', 'border-4');
    });

    // Add selected class to the clicked container
    const selectedContainer = document.querySelector(`.theme-container[onclick*="${theme}"]`);
    selectedContainer.classList.add('border-[#cca385]', 'border-4');
}

  function performGeocoding(query) {
    if (!query) {
      document.getElementById('geocoder-results').classList.add('hidden');
      return;
    }
  

    const geocodingUrl = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${mapboxgl.accessToken}`;
  
    fetch(geocodingUrl)
      .then(response => response.json())
      .then(data => {
        const resultsContainer = document.getElementById('geocoder-results');
        resultsContainer.innerHTML = ''; // Clear previous results
        data.features.forEach(feature => {
          const placeName = feature.place_name;
          const coord = feature.geometry.coordinates;
  
          const resultItem = document.createElement('div');
          resultItem.className = 'p-2 hover:bg-[#cca385] cursor-pointer';
          resultItem.textContent = placeName;
          resultItem.onclick = () => {
            updateLatestLocation(placeName, coord); // Update the latest location
            resultsContainer.classList.add('hidden'); // Hide the results after selection
          };
          resultsContainer.appendChild(resultItem);
        });
        resultsContainer.classList.remove('hidden');
      })
      .catch(error => {
        console.error('Error with geocoding:', error);
      });
  }
  
  
  
  function updateLatestLocation(placeName, coord) {
    const locationsContainer = document.getElementById('locationsContainer');
    const locationRows = locationsContainer.querySelectorAll('div');

    if (locationRows.length === 0) {
        alert("No location input available. Please add a location first.");
        return;
    }

    // Find the last updated location input (this will be the container being modified)
    const latestLocation = locationRows[locationRows.length - 1];
    const inputField = latestLocation.querySelector('input');

    // Get the index of the current container to track the marker
    const locationIndex = Array.from(locationRows).indexOf(latestLocation);

    // Remove the existing marker for this location if it exists
    if (markers[locationIndex]) {
        markers[locationIndex].remove(); // Remove the previous marker from the map
    }

    // Update the input field with the new place name
    inputField.value = placeName;

    // Store lat/lng in the latest location dataset
    latestLocation.dataset.lat = coord[1]; // Store latitude
    latestLocation.dataset.lng = coord[0]; // Store longitude

    // Add the new marker to the map
    addPointToMap(coord, placeName, locationIndex);

    // Trigger the city name update on the canvas
    updateCityNames();  
}

  
  
  let markers = []; // Array to store map markers
  
  let routeColors = {
  blue: '#566d71',   // Blue theme route color
  green: '#28a745',  // Green theme route color (added for green)
  red: '#ff4c4c',    // Red theme route color
  yellow: '#ffc107', // Yellow theme route color
  purple: '#6f42c1', // Purple theme route color
  orange: '#fd7e14', // Orange theme route color
  pink: '#e83e8c',   // Pink theme route color
  gray: '#6c757d'    // Gray theme route color
};


let themeColors = {
  blue: '#5b7373',   // Blue theme color
  green: '#28a745',  // Green theme color (added for green)
  red: '#ff4c4c',    // Red theme color
  yellow: '#ffc107', // Yellow theme color
  purple: '#6f42c1', // Purple theme color
  orange: '#fd7e14', // Orange theme color
  pink: '#e83e8c',   // Pink theme color
  gray: '#6c757d'    // Gray theme color
};

let selectedTheme = 'blue'; // Default theme

// Define an empty GeoJSON object to store the marker points
let geojsonData = {
    type: 'FeatureCollection',
    features: []
};

// Add a source and layer to the map for the markers
map.on('load', function () {
    // Add a GeoJSON source for markers if it doesn't exist already
    if (!map.getSource('markers')) {
        map.addSource('markers', {
            type: 'geojson',
            data: geojsonData // Initially empty
        });
    }

    // Add a circle layer to display the markers
    if (!map.getLayer('circle-markers')) {
        map.addLayer({
            id: 'circle-markers',
            type: 'circle',
            source: 'markers',
            paint: {
                'circle-radius': 6 , // Size of the circle
                'circle-color': '#ffffff', // White background
                'circle-stroke-color': themeColors[selectedTheme], // Border color from theme
                'circle-stroke-width': 2, // Border width
                
            }
        });
    }
});

// Function to add a point to the GeoJSON source
function addPointToMap(coordinates, placeName, index) {
    // Create a new feature for the GeoJSON data
    const newFeature = {
        type: 'Feature',
        geometry: {
            type: 'Point',
            coordinates: coordinates // The coordinates of the point
        },
        properties: {
            description: placeName, // Add place name for popups or other use
            index: index // Add index to track specific markers
        }
    };

    // Replace the feature in the geojsonData or add a new one if it doesn't exist
    if (geojsonData.features[index]) {
        geojsonData.features[index] = newFeature; // Replace the existing feature
    } else {
        geojsonData.features.push(newFeature); // Add a new feature
    }

    // Update the GeoJSON source data on the map
    map.getSource('markers').setData(geojsonData);

    // Fly to the new marker location
    map.flyTo({
        center: coordinates,
        essential: true,
        zoom: 14
    });
}

// Optional: Add a popup when clicking on markers in the circle layer
map.on('click', 'circle-markers', function (e) {
    const coordinates = e.features[0].geometry.coordinates.slice();
    const description = e.features[0].properties.description;

    // Ensure the map properly pans for popups
    new mapboxgl.Popup()
        .setLngLat(coordinates)
        .setHTML(`<strong>${description}</strong>`)
        .addTo(map);
});

// Optional: Change the cursor when hovering over markers
map.on('mouseenter', 'circle-markers', function () {
    map.getCanvas().style.cursor = 'pointer';
});

map.on('mouseleave', 'circle-markers', function () {
    map.getCanvas().style.cursor = '';
});

function calculateRoute() {
    const coordinates = [];
    document.querySelectorAll('#locationsContainer > div').forEach(location => {
        const lat = location.dataset.lat;
        const lng = location.dataset.lng;
        if (lat && lng) {
            coordinates.push([parseFloat(lng), parseFloat(lat)]); // Coordinates are stored as [lng, lat]
        }
    });

    if (coordinates.length < 2) {
        alert("Please enter at least two valid locations.");
        return;
    }

    // Initialize arrays to hold the route data
    const fullRoute = [];
    const failedSegments = [];

    // Function to fetch route for a pair of coordinates (start and end)
    function fetchRouteForSegment(start, end, callback) {
        const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${start[0]},${start[1]};${end[0]},${end[1]}?geometries=geojson&access_token=${mapboxgl.accessToken}`;
        
        fetch(url)
            .then(response => response.json())
            .then(data => {
                if (data.routes && data.routes.length > 0) {
                    // If a route is found, add it to the full route
                    callback(data.routes[0].geometry);
                } else {
                    // If no route is found, add the pair of points to the failed segments (straight line)
                    failedSegments.push([start, end]);
                    callback(null);
                }
            })
            .catch(error => {
                console.error('Error fetching route:', error);
                callback(null);
            });
    }

    // Function to process all segments (consecutive locations)
    function processSegments(index) {
        if (index >= coordinates.length - 1) {
            // Once all segments are processed, display the entire route (with straight lines where necessary)
            displayRouteOnMap(fullRoute, failedSegments);
            return;
        }

        const start = coordinates[index];
        const end = coordinates[index + 1];

        // Fetch route for the current segment
        fetchRouteForSegment(start, end, function(route) {
            if (route) {
                // If route is available, add the route coordinates to fullRoute
                fullRoute.push(route.coordinates);
            }
            // Move on to the next segment (pair of locations)
            processSegments(index + 1);
        });
    }

    // Start processing from the first segment
    processSegments(0);
}

let straightLineLayers = []; // Array to keep track of straight line layer IDs

function displayRouteOnMap(route, failedSegments) {
    // Remove any existing route layers and sources
    if (map.getSource('route')) {
        map.removeLayer('route');
        map.removeSource('route');
    }

    // Create a GeoJSON FeatureCollection for all segments
    const routeFeatures = route.map(segment => ({
        type: 'Feature',
        geometry: {
            type: 'LineString',
            coordinates: segment
        }
    }));

    // Create a GeoJSON FeatureCollection for all failed segments
    const failedFeatures = failedSegments.map(([start, end]) => ({
        type: 'Feature',
        geometry: {
            type: 'LineString',
            coordinates: [start, end]
        }
    }));

    // Combine route and failed segments into a single FeatureCollection
    const allFeatures = {
        type: 'FeatureCollection',
        features: [...routeFeatures, ...failedFeatures]
    };

    // Add the combined GeoJSON to the map
    map.addSource('route', {
        type: 'geojson',
        data: allFeatures
    });

    map.addLayer({
        id: 'route',
        type: 'line',
        source: 'route',
        layout: {
            'line-join': 'round',
            'line-cap': 'round'
        },
        paint: {
            'line-color': routeColors[selectedTheme], // Use your color scheme
            'line-width': 4
        }
    }, 'circle-markers'); // Add the layer below the markers

    // Fit map bounds to include all segments
    const bounds = new mapboxgl.LngLatBounds();
    route.forEach(segment => {
        segment.forEach(coord => bounds.extend(coord));
    });

    failedSegments.forEach(([start, end]) => {
        bounds.extend(start);
        bounds.extend(end);
    });

    map.fitBounds(bounds, { padding: 50 });
}


// Get the canvas element and context
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

// City names display toggle
let displayCityNames = true;

// Adjust the canvas size dynamically if needed
function resizeCanvas() {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // Redraw the city names whenever the canvas size changes
    if (displayCityNames) {
        displaytext ();
    }
}

// Call resizeCanvas on load and window resize
window.addEventListener('load', resizeCanvas);
window.addEventListener('resize', resizeCanvas);


let printtextcolor;

// Initialize global variables
let alignmentOption = 'right';
let fontStyleOption = 'normal';
let fontFamilyOption = 'Arial';




function printtext(ctx, canvasWidth, canvasHeight) {
    if (displayCityNames === false) { return; }

    // Get all location input fields
    const locationRows = document.querySelectorAll('#locationsContainer > div');
    const textColor = printtextcolor; 

    // Scaling factors based on the original dimensions (7200x5400)
    const widthScale = canvasWidth / 7200;
    const heightScale = canvasHeight / 5400;

    // Adjusted font sizes and line heights based on scaling factors for city names
    const fontSize = 140 * heightScale; // Adjust font size relative to canvas height
    const lineHeight = 180 * heightScale; // Adjust line height relative to canvas height

    ctx.fillStyle = textColor; // Set text color
const fontStyle = fontStyleOption || 'normal'; // Use global font style option
    const fontFamily = fontFamilyOption || 'Arial'; // Use global font family option

    ctx.font = `${fontStyle} ${fontSize}px ${fontFamily}    `; // Keep font fixed for city names
    ctx.textAlign = 'left'; // Fix alignment to the left for city names
    ctx.textBaseline = 'alphabetic'; // Standard text baseline for city names

    // Start drawing city names from the bottom left of the canvas (scaled for any canvas size)
    const startY = canvasHeight - 200 * heightScale; // Adjust Y starting point relative to canvas height
    const startX = 200 * widthScale; // Fixed X starting point for city names

    // Draw city names from the bottom up
    locationRows.forEach((row, index) => {
        const inputField = row.querySelector('input');
        const cityName = inputField.value.trim() || `City ${index + 1}`; // Default to "City X" if empty

        const positionY = startY - (locationRows.length - 1 - index) * lineHeight; // Calculate Y position from bottom up
        ctx.fillText(`${index + 1}. ${cityName}`, startX, positionY); // Draw city name text
    });

    // Get user input for title, message, and subtext
    const title = titleInput.value.trim() || ''; // Default to 'Title' if empty
    const message = messageInput.value.trim() || ''; // Default to 'Message' if empty
    const subText = subTextInput.value.trim() || ''; // Default to 'Subtext' if empty

    // Adjusted font sizes for title, message, and subtext
    const titleFontSize = 220 * heightScale;
    const messageFontSize = 180 * heightScale;
    const subTextFontSize = 140 * heightScale;

    const alignment = alignmentOption || 'right'; // Use global alignment option (default to right)

    ctx.fillStyle = textColor; // Set the fill color to theme color
    ctx.textAlign = alignment; // Apply user-selected alignment for title, message, subtext
    ctx.textBaseline = 'top'; // Align text to the top

    // Adjusted position for text at the top-right corner
    const margin = 200 * widthScale; // Adjust margin relative to canvas width
    const titleX = alignment === 'left' ? margin 
                 : alignment === 'center' ? canvasWidth / 2 
                 : canvasWidth - margin;
    const titleY = margin;

    // Draw the title at the top-right
    ctx.font = `${fontStyle} bold ${titleFontSize}px ${fontFamily}`; // Title font with user-selected options
    ctx.fillText(title, titleX, titleY);

    // Draw the message below the title
    ctx.font = `${fontStyle} ${messageFontSize}px ${fontFamily}`; // Message font with user-selected options
    const messageY = titleY + titleFontSize + 60 * heightScale; // Adjust message Y position
    ctx.fillText(message, titleX, messageY);

    // Draw the subtext below the message
    ctx.font = `${fontStyle} ${subTextFontSize}px ${fontFamily}`; // Subtext font with user-selected options
    const subTextY = messageY + messageFontSize + 60 * heightScale; // Adjust subtext Y position
    ctx.fillText(subText, titleX, subTextY);
}


// Get references to the text input fields
const titleInput = document.getElementById('titleInput');
const messageInput = document.getElementById('messageInput');
const subTextInput = document.getElementById('subTextInput');


// Event listeners to update the canvas as the user types
titleInput.addEventListener('input', displaytext );
messageInput.addEventListener('input', displaytext );
subTextInput.addEventListener('input', displaytext );



// Functions to update each option based on user input
function updateAlignmentOption(value) {
  alignmentOption = value;
  displaytext (); // Redraw to apply changes
}

function updateFontStyleOption(value) {
  fontStyleOption = value;
  displaytext (); // Redraw to apply changes
}

function updateFontFamilyOption(value) {
  fontFamilyOption = value;
  displaytext (); // Redraw to apply changes
}

function displaytext (textColor = themeColors[selectedTheme]) {
  printtextcolor = textColor;

  if (displayCityNames == false) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous drawings

  const fontSize = 14; // Set the font size for city names
  const lineHeight = 20; // Line height between text entries
  ctx.fillStyle = textColor; // Set text color
  ctx.font = `${fontSize}px ${fontFamilyOption}`; // Set font size and family for city names

  // Start drawing city names from the bottom left of the canvas
  const startY = canvas.height - 20; // Position 20px from the bottom of the canvas
  const startX = 20; // Position 20px from the left edge of the canvas

  // Ensure text alignment is set to 'left' for the city names
  ctx.textAlign = 'left'; // Set text alignment to left for city names
  ctx.textBaseline = 'alphabetic'; // Standard text baseline for city names

  // Draw city names from the bottom up
  const locationRows = document.querySelectorAll('#locationsContainer > div');
  locationRows.forEach((row, index) => {
    const inputField = row.querySelector('input');
    const cityName = inputField.value.trim() || `City ${index + 1}`; // Default to "City X" if empty

    const positionY = startY - (locationRows.length - 1 - index) * lineHeight; // Calculate Y position from bottom up

    // Draw the city name text at the calculated position
    ctx.fillText(`${index + 1}. ${cityName}`, startX, positionY);
  });

  // Get user input for title, message, and subtext
  const title = titleInput.value.trim() 
  const message = messageInput.value.trim() 
  const subText = subTextInput.value.trim() 

  // Set text properties for the title, message, and subtext
  const titleFontSize = 24; // Title font size
  const messageFontSize = 18; // Message font size
  const subTextFontSize = 14; // Subtext font size

  // Set font and alignment for title, message, and subtext
  ctx.fillStyle = textColor; // Set the fill color to theme color
  ctx.textAlign = alignmentOption; // Set alignment
  ctx.textBaseline = 'top'; // Align text to the top

  // Position for text at the top based on alignment
  const margin = 20; // Margin from the edges
  let titleX;
  if (alignmentOption === 'left') {
    titleX = margin;
  } else if (alignmentOption === 'center') {
    titleX = canvas.width / 2;
  } else { // default to 'right'
    titleX = canvas.width - margin;
  }
  const titleY = margin;

  // Draw the title with selected font style and family
  ctx.font = `${fontStyleOption} bold ${titleFontSize}px ${fontFamilyOption}`;
  ctx.fillText(title, titleX, titleY);

  // Draw the message below the title
  ctx.font = `${fontStyleOption} ${messageFontSize}px ${fontFamilyOption}`;
  const messageY = titleY + titleFontSize + 10; // Position message below title
  ctx.fillText(message, titleX, messageY);

  // Draw the subtext below the message
  ctx.font = `${fontStyleOption} ${subTextFontSize}px ${fontFamilyOption}`;
  const subTextY = messageY + messageFontSize + 10; // Position subtext below message
  ctx.fillText(subText, titleX, subTextY);
}


// Function to update city names on canvas when input changes
function updateCityNames() {
    displaytext (); // Directly call the drawing function
}




// Toggle visibility of city names
document.getElementById('toggleCityNames').addEventListener('click', () => {
    displayCityNames = !displayCityNames;
    if (displayCityNames) {
        displaytext (); // Redraw city names if they're being displayed
    } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas if not displaying
    }
});



function updateLandColor(color) {

    const landLayerId = 'land';
    map.setPaintProperty(landLayerId, 'background-color', color);
}

function updateWaterColor(color) {

    const waterLayerId = 'water'; // Adjust according to your layer ID
    map.setPaintProperty(waterLayerId, 'fill-color', color);
}

function updateRouteColor(color) {
    // Update the color for the main route
    if (map.getLayer('route')) {
        map.setPaintProperty('route', 'line-color', color);
    }

    // Update the color for all straight-line segments
    straightLineLayers.forEach(layerId => {
        if (map.getLayer(layerId)) {
            map.setPaintProperty(layerId, 'line-color', color);
        }
    });
}


function updateTextColor(color){
displaytext (color);
}
function updateMarkerColor(color){
  map.setPaintProperty('circle-markers', 'circle-stroke-color', color);
}

document.getElementById('generate-btn').addEventListener('click', generateMap);

function generateMap() {
        'use strict';
       

        // Get user-defined values for width, height, and DPI
        let width = Number(document.getElementById('widthInput').value);  // User input for width
        let height = Number(document.getElementById('heightInput').value);  // User input for height
        const dpi = Number(document.getElementById('dpiInput').value);  // User input for DPI
        const format = document.getElementById('outputOptions').value === 'png' ? 'png' : 'pdf';  // Output format


        if (format === 'pdf') {
    if (printsize === 'size24x18') {
        width = 4.32;
        height = 3.24;
    } else if (printsize === 'size18x12') {
        width = 3.24;
        height = 2.24;
    } else if (printsize === 'size8_5x11') { // New size for PDF
        width = 1.98;  // Width in inches
        height = 1.53; // Height in inches
    }
} else if (format === 'png') {
    map.setPaintProperty('circle-markers', 'circle-radius', 20);
    map.setPaintProperty('circle-markers', 'circle-stroke-width', 5);
    map.setPaintProperty('route', 'line-width', 9);

    if (printsize === 'size24x18') {
        width = 8; // Width in inches
        height = 6; // Height in inches
    } else if (printsize === 'size18x12') {
        width = 6; // Width in inches
        height = 4; // Height in inches
    } else if (printsize === 'size8_5x11') { // New size for PNG
        width = 3.667;  // Width in inches
        height = 2.839;  // Height in inches
    }
}


if (orientation === 'portrait') {
        // Swap width and height for portrait mode
        [width, height] = [height, width];
    }

        if (width <= 0 || height <= 0 || dpi <= 0) {
            alert("Width, height, and DPI must be positive numbers!");
            return;
        }

        // Calculate the required pixel dimensions based on DPI
        const pixelWidth = width * dpi;
        const pixelHeight = height * dpi;

        
        // Get current map state
        const zoom = map.getZoom();
        const center = map.getCenter();
        const bearing = map.getBearing();
        const pitch = map.getPitch();
        const style = map.getStyle();


        map.setPaintProperty('circle-markers', 'circle-radius', 6);
        map.setPaintProperty('circle-markers', 'circle-stroke-width', 2);
        map.setPaintProperty('route', 'line-width', 4);

        // Create the high-resolution map
        createPrintMap(pixelWidth, pixelHeight, dpi, format, zoom, center, bearing, pitch, style);
    }
    function createPrintMap(pixelWidth, pixelHeight, dpi, format, zoom, center, bearing, pitch, style) {
    'use strict';

    // Adjust the devicePixelRatio for high-resolution rendering
    const actualPixelRatio = window.devicePixelRatio;
    Object.defineProperty(window, 'devicePixelRatio', {
        get: function () { return dpi / 96; }
    });

    // Calculate the display container size (800x600 in your case)
    const containerWidth = 800;  // The width of the visible map container
    const containerHeight = 600;  // The height of the visible map container

    // Adjust the zoom level to compensate for the larger pixel dimensions
    const adjustedZoom = zoom + Math.log2(Math.min(pixelWidth / containerWidth, pixelHeight / containerHeight));

    // Create a hidden map container for rendering the high-resolution map
    const hiddenMapContainer = document.createElement('div');
    hiddenMapContainer.style.width = pixelWidth + 'px';
    hiddenMapContainer.style.height = pixelHeight + 'px';
    hiddenMapContainer.style.position = 'absolute';   // Prevent affecting page layout
    hiddenMapContainer.style.top = '-9999px';         // Move it out of the viewport
    hiddenMapContainer.style.left = '-9999px';        // Move it out of the viewport
    hiddenMapContainer.style.clip = 'rect(0, 0, 0, 0)';  // Ensure it's fully clipped
    document.body.appendChild(hiddenMapContainer);

    // Create a canvas element
    const hiddenCanvas = document.createElement('canvas');
    hiddenCanvas.width = pixelWidth * 3;
    hiddenCanvas.height = pixelHeight * 3;

    // Append the canvas to the hidden map container
    hiddenMapContainer.appendChild(hiddenCanvas);

    // Initialize a new Mapbox map in the hidden container
    const printMap = new mapboxgl.Map({
        container: hiddenMapContainer,
        center: center,
        zoom: adjustedZoom,  // Use the adjusted zoom level
        style: style,
        bearing: bearing,
        pitch: pitch,
        interactive: false,  // Disable interactions for the print map
        preserveDrawingBuffer: true  // Necessary for toBlob() or toDataURL()
    });

    // Wait until the map finishes loading before exporting
    printMap.once('load', function () {
    
            

        const hiddenCtx = hiddenCanvas.getContext('2d');

        // Get the original canvas
        const originalCanvas = printMap.getCanvas();

        // Draw the original canvas onto the hidden canvas
        hiddenCtx.drawImage(originalCanvas, 0, 0);


        // Optional: If you have text to print on the map
        printtext(hiddenCtx,hiddenCanvas.width,hiddenCanvas.height);

        if (format === 'png') {
            hiddenCanvas.toBlob(function (blob) {
                // Download the PNG
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'map.png';
                link.click();

                // Clean up
                URL.revokeObjectURL(link.href);
                hiddenCanvas.remove();
                document.body.removeChild(hiddenMapContainer);
                Object.defineProperty(window, 'devicePixelRatio', { get: function () { return actualPixelRatio; } });
            });
        } else {console.log(pixelWidth + " H " +pixelHeight);
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: pixelWidth > pixelHeight ? 'l' : 'p',
                unit: 'pt',
                format: [pixelWidth, pixelHeight]
            });

            pdf.addImage(hiddenCanvas.toDataURL('image/png'), 'PNG', 0, 0, pixelWidth, pixelHeight);
            pdf.save('map.pdf');

            // Clean up
            hiddenCanvas.remove();
            document.body.removeChild(hiddenMapContainer);
            Object.defineProperty(window, 'devicePixelRatio', { get: function () { return actualPixelRatio; } });
        }
       
        printMap.remove();
        map.resize();
    });
}

        </script>
    </body>
    </html>
