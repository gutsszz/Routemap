    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Travel Route Planner</title>
      <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400&display=swap" rel="stylesheet">
      <link href="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
      
      <script src="https://cdn.tailwindcss.com"></script>
      <style>
        .transition-transform {
          transition: transform 0.3s ease;
        }
        .dropdown-text {
          font-family: 'Lora', sans-serif;
          font-size: 14px;
        }
        .arrow {
          font-family: 'Lora', Arial, sans-serif; /* Add fallbacks */

          transition: transform 0.3s ease;
        }
        .arrow-down {
          transform: rotate(90deg);
        }
        

        /* Custom scrollbar styles */
    ::-webkit-scrollbar {
      width: 6px; /* Reduced width */
    }

    ::-webkit-scrollbar-track {
      background: #f1f1f1; /* Light gray track */
      border-radius: 10px; /* Rounded corners */
    }

    ::-webkit-scrollbar-thumb {
      background: #cca385; /* Light brown thumb */
      border-radius: 10px; /* Rounded corners */
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #b59c74; /* Darker shade on hover */
    }



      /* Media query for smaller screens */
      @media (max-width: 768px) {
          /* Make sidebar cover the entire screen */
          #sidebar {
            width: 100%;
            height: 100%;
            z-index: 10;
          }

          /* Hide large map and show preview on top of sidebar */
          #mapWrapper {
            display: none;
          }

          #previewContainer {
            display: block;
            width: 80vw;
            height: 60vw;
            top: 70%;
            left: 15%;
            right: 5%;
            z-index: 50;
          }
        }
      </style>
    </head>
    <body class="bg-gray-100">

      <!-- Top Bar -->
      <div class="w-full bg-white h-16 flex items-center justify-between px-4 shadow-lg z-10 fixed top-0">
        <button id="toggleSidebar" class="text-[#cca385] text-2xl">&#9776;</button>
        <div class="text-2xl font-semibold text-[#cca385]">Route Map</div>
      </div>

      <!-- Main Content -->
      <div class="flex pt-16 h-screen">
        
        <!-- Sliding Bar -->
        <div id="sidebar" class="w-80 h-screen bg-white shadow-md p-4  fixed z-20">
          
          
          <!-- Dropdown Menus -->
          <div class="space-y-4">
            <div class="dropdown border-b border-gray-200">
              <button class="w-full text-left bg-[#f9f9f9] p-3 rounded-lg hover:bg-[#e5e5e5] focus:outline-none flex items-center dropdown-text" onclick="toggleDropdown('dropdown1', this)">
                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 w-5 h-5 text-[#cca385] arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>                 Places
              </button>
              <div id="dropdown1" class="hidden pl-4">
                <div class="relative mb-4 mt-2">
                  <input id="geocoder-input" 
                         class="w-full p-2 bg-white text-black border border-gray-300 rounded-md focus:border-[#cca385]" 
                         type="text" 
                         placeholder="Search for a place..." 
                         oninput="performGeocoding(this.value)" />
                  <!-- Geocoding results dropdown -->
                  <div id="geocoder-results" 
                       class="absolute w-full bg-white text-black rounded-md border border-gray-300 mt-1 z-10 hidden">
                  </div>
                </div>
        
                <!-- Scrollable container for inputs -->
                <div id="locationsContainer" class="flex flex-col space-y-2 max-h-40 overflow-y-auto mt-2 pr-2">

                  <!-- First input row -->
                 
                </div>
                <!-- Add button below inputs -->
                <div class="flex justify-center space-x-4 my-6">
                  <button onclick="addLocation()" class="bg-[#cca385] text-white px-6 py-1 rounded w-full">Add</button>
                  <button onclick="calculateRoute()" class="bg-[#cca385] text-white px-6 py-1 rounded w-full">Route</button>
                </div>
                
              </div>
            </div>



            <div class="dropdown border-b border-gray-200">
              <button class="w-full text-left bg-[#f9f9f9] p-3 rounded-lg hover:bg-[#e5e5e5] focus:outline-none flex items-center dropdown-text" onclick="toggleDropdown('dropdown2', this)">
                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 w-5 h-5 text-[#cca385] arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>                 Theme
              </button>
              <div id="dropdown2" class="hidden pl-4">
                <div class="flex space-x-4 mt-2 mb-4">
                  <div class="w-12 h-12 bg-blue-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('blue')">
                    <div class="w-6 h-6 bg-blue-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-green-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('green')">
                    <div class="w-6 h-6 bg-green-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-red-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('red')">
                    <div class="w-6 h-6 bg-red-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-yellow-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('yellow')">
                    <div class="w-6 h-6 bg-yellow-700 rounded-full"></div>
                  </div>
                </div>
                <div class="flex space-x-4 mb-4">
                  <div class="w-12 h-12 bg-purple-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('purple')">
                    <div class="w-6 h-6 bg-purple-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-orange-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('orange')">
                    <div class="w-6 h-6 bg-orange-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-pink-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('pink')">
                    <div class="w-6 h-6 bg-pink-700 rounded-full"></div>
                  </div>
                  <div class="w-12 h-12 bg-gray-300 flex items-center justify-center border-4 border-transparent hover:border-[#cca385] theme-container" onclick="selectTheme('gray');">
                    <div class="w-6 h-6 bg-gray-700 rounded-full"></div>
                  </div>
                </div>
                
                
                <!-- Color Options Section -->
<div id="customThemeDropdown" class=" pl-4 mt-2">
  <!-- Row 1 -->
  <div class="flex space-x-4 mb-4">
    <!-- Land Color -->
    <div class="w-full">
      <p class="dropdown-text text-gray-600">Land Color:</p>
      <div class="flex mt-1">
        <input type="color" id="landColor" class="w-8 h-8  border rounded" onchange="updateLandColor(this.value)">
      </div>
    </div>
    <!-- Water Color -->
    <div class="w-full">
      <p class="dropdown-text text-gray-600">Water Color:</p>
      <div class="flex mt-1">
        <input type="color" id="waterColor" class="w-8 h-8  border rounded" onchange="updateWaterColor(this.value)">
      </div>
    </div>
  </div>

  <!-- Row 2 -->
  <div class="flex space-x-4 mb-4">
    <!-- Route Color -->
    <div class="w-full">
      <p class="dropdown-text text-gray-600">Route Color:</p>
      <div class="flex mt-1">
        <input type="color" id="routeColor" class="w-8 h-8  border rounded" onchange="updateRouteColor(this.value)">
      </div>
    </div>
    <!-- Marker Color -->
    <div class="w-full">
      <p class="dropdown-text text-gray-600">Marker Color:</p>
      <div class="flex mt-1">
        <input type="color" id="markerColor" class="w-8 h-8  border rounded" onchange="updateMarkerColor(this.value)">
      </div>
    </div>
  </div>
</div>


              </div>
            </div>
            

            <div class="dropdown border-b border-gray-200">
              <button class="w-full text-left bg-[#f9f9f9] p-3 rounded-lg hover:bg-[#e5e5e5] focus:outline-none flex items-center dropdown-text" onclick="toggleDropdown('dropdown3', this)">
                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 w-5 h-5 text-[#cca385] arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>                 
                Text 
              </button>
              
              <div id="dropdown3" class="hidden pl-4 pr-2 overflow-y-auto" style="max-height: 300px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);"> <!-- Added styles for better appearance -->
                
                <!-- Alignment Option Dropdown -->
                <div class="flex items-center mt-4 mb-3">
                  <label for="alignmentOption" class="dropdown-text text-gray-600 mr-3">Alignment:</label>
                  <select id="alignmentOption" class="border p-2 rounded-lg text-gray-700" onchange="updateAlignmentOption(this.value)">
                    <option value="right">Right</option>
                    <option value="center">Center</option>
                    <option value="left">Left</option>
                  </select>
                </div>
                
                <!-- Font Style Option Dropdown -->
                <div class="flex items-center mt-4 mb-3">
                  <label for="fontStyleOption" class="dropdown-text text-gray-600 mr-3">Font Style:</label>
                  <select id="fontStyleOption" class="border p-2 rounded-lg text-gray-700" onchange="updateFontStyleOption(this.value)">
                    <option value="normal">Normal</option>
                    <option value="bold">Bold</option>
                    <option value="italic">Italic</option>
                  </select>
                </div>
                
                <!-- Font Family Option Dropdown -->
                <div class="flex items-center mt-4 mb-3">
                  <label for="fontFamilyOption" class="dropdown-text text-gray-600 mr-3">Font Family:</label>
                  <select id="fontFamilyOption" class="border p-2 rounded-lg text-gray-700" onchange="updateFontFamilyOption(this.value)">
                    <option value="Arial">Arial</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                  </select>
                </div>
            
                <!-- Existing Text Color Picker and Hide Text Switch -->
                <div class="w-full flex items-center justify-between mt-4 mb-3">
                  <div class="flex items-center">
                    <p class="dropdown-text text-gray-600 mr-3">Text Color:</p>
                    <input type="color" id="textColor" class="w-8 h-8 border rounded" onchange="updateTextColor(this.value)">
                  </div>
                  <div class="flex items-center">
                    <label for="toggleCityNames" class="dropdown-text mr-3 text-gray-700">Hide Text</label>
                    <div class="relative">
                      <input type="checkbox" id="toggleCityNames" class="peer appearance-none w-10 h-5 bg-gray-300 rounded-full cursor-pointer transition duration-200 focus:outline-none checked:bg-[#cca385]" />
                      <span class="absolute left-1 top-0.5 w-4 h-4 bg-white rounded-full transition-transform duration-200 ease-in-out transform peer-checked:translate-x-4 pointer-events-none"></span>
                    </div>
                  </div>
                </div>
            
                <!-- Title Input Box -->
                <div class="mt-2 mb-4">
                  <label for="titleInput" class="dropdown-text text-gray-600">Title:</label>
                  <input type="text" id="titleInput" placeholder="Enter a title" class="border p-2 rounded w-full mt-1">
                </div>
            
                <!-- Text Message Box -->
                <div class="mt-4 mb-4">
                  <label for="messageInput" class="dropdown-text text-gray-600">Text:</label>
                  <textarea id="messageInput" placeholder="Enter your text" class="border p-2 rounded w-full mt-1" rows="4"></textarea>
                </div>
            
                <!-- Sub-Text Message Box -->
                <div class="mt-4 mb-4">
                  <label for="subTextInput" class="dropdown-text text-gray-600">Sub-Text:</label>
                  <textarea id="subTextInput" placeholder="Enter your sub-text" class="border p-2 rounded w-full mt-1" rows="3"></textarea>
                </div>
              </div>
            </div>
                          
            <div class="dropdown">
              <button class="w-full text-left bg-[#f9f9f9] p-3 rounded-lg hover:bg-[#e5e5e5] focus:outline-none flex items-center dropdown-text" onclick="toggleDropdown('dropdown4', this)">
                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 w-5 h-5 text-[#cca385] arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
                Size
              </button>
            
              <div id="dropdown4" class="hidden pl-4 mt-2">
             
                <!-- Size Selection Boxes -->
                <div class="mt-4 flex space-x-4" id="sizeSelector">
                  <button 
                    class="w-24 h-16 bg-gray-200 border rounded-lg flex items-center justify-center hover:bg-gray-300 focus:bg-gray-300 focus:outline-none" 
                    onclick="setSize('size24x18', this)">
                    24x18
                  </button>
                  <button 
                    class="w-24 h-16 bg-gray-200 border rounded-lg flex items-center justify-center hover:bg-gray-300 focus:bg-gray-300 focus:outline-none" 
                    onclick="setSize('size18x12', this)">
                    18x12
                  </button>
                </div>
                
                <!-- Hidden inputs to store values -->
                <input type="hidden" id="selectedSize" value="size24x18"> <!-- Default value -->
            
                <!-- Hidden Inputs for DPI, Width, Height -->
                <div class="hidden">
                  <label for="widthInput">Width (inches):</label>
                  <input type="number" id="widthInput" value="8" step="0.1">
                  <label for="heightInput">Height (inches):</label>
                  <input type="number" id="heightInput" value="6" step="0.1">
                  <label for="dpiInput">DPI:</label>
                  <input type="number" id="dpiInput" value="300">
                </div>
            
                <!-- Output Format Dropdown -->
                <div class="mt-4">
                  <label for="outputOptions" class="block text-gray-600">Output format:</label>
                  <select id="outputOptions" class="p-2 border rounded w-full focus:outline-none">
                    <option value="png">PNG</option>
                    <option value="pdf">PDF</option>
                  </select>
                </div>
                <div class="flex justify-center space-x-4 my-6">
                  <button id="generate-btn" class="bg-[#cca385] text-white px-6 py-1 rounded w-full"> Print</button>
                </div>
                 
               
              </div>
            </div>
            



          </div>
        </div>
        <div id="mapWrapper" class="flex-1 bg-gray-200 ml-64 relative">
          <div id="mapContainer" class="absolute top-0 bottom-0 left-0 right-0 m-auto" style="width: 60%; aspect-ratio: 4 / 3; background-color: white; box-shadow: 0px 4px 15px rgba(0, 0, 0, 0.2); z-index: 10;">
            <div id="map" class="flex items-center justify-center w-full h-full text-gray-500">
              <!-- Map will appear here -->
            </div>
            <!-- Canvas overlay -->
            <canvas id="mapCanvas" class="absolute top-0 left-0 w-full h-full" style="pointer-events: none;"></canvas>
          </div>
        </div>
        
        
    <!-- Preview Container for smaller screens -->
    <div id="previewContainer" class="hidden bg-white fixed p-4 shadow-xl" style="z-index: 50;">
      <!-- Semi-transparent background -->
      <div class="absolute inset-0 bg-white opacity-80"></div>
      
      <!-- Map content above the background -->
      <div id="previewMap" class="relative flex items-center justify-center w-full h-full text-gray-500">
        
      </div>
    </div>

    </div>
      

    <script>

      mapboxgl.accessToken = 'pk.eyJ1IjoidGFsaGF3YXFxYXMxNCIsImEiOiJjbHBreHhscWEwMWU4MnFyenU3ODdmeTdsIn0.8IlEgMNGcbx806t363hDJg';
          let mapContainer = document.getElementById('mapContainer');
          let mapElement = document.getElementById('map');
          let previewContainer = document.getElementById('previewContainer');
          let previewMapElement = document.getElementById('previewMap');
  
      const map = new mapboxgl.Map({
      container: 'map',
  
      style: 'mapbox://styles/talhawaqqas14/cm1s96dl200yw01qvet4c70x3',
      zoom: 1.2,
      center: [-145, 30],
      preserveDrawingBuffer: true,
  
      });

  
  
      function moveMapToPreview() {
            if (window.innerWidth <= 768) {
              // Move map to preview container
              if (!previewMapElement.contains(mapElement)) {
                previewMapElement.appendChild(mapElement);
                map.resize(); // Ensure the map resizes correctly in the smaller container
              }
            } else {
              // Move map back to the main container
              if (!mapContainer.contains(mapElement)) {
                mapContainer.appendChild(mapElement);
                map.resize(); // Resize map back in the larger container
              }
            }
          }
  
          // Call the function initially
          moveMapToPreview();
  
          // Adjust on window resize
          window.addEventListener('resize', moveMapToPreview);
  
  
        
         // Function to toggle dropdowns
  function toggleDropdown(dropdownId, button) {
    const dropdowns = document.querySelectorAll('.dropdown > div');
    const arrows = document.querySelectorAll('.arrow');
  
    // Close all other dropdowns
    dropdowns.forEach((dropdown) => {
      if (dropdown.id !== dropdownId) {
        dropdown.classList.add('hidden'); // Close other dropdowns
      }
    });
  
    // Reset all arrows
    arrows.forEach((arrow) => {
      if (!dropdownId.includes(arrow.closest('.dropdown').querySelector('div').id)) {
        arrow.classList.remove('arrow-down'); // Reset other arrows
      }
    });
  
    // Toggle the clicked dropdown and arrow
    const dropdown = document.getElementById(dropdownId);
    const arrow = button.querySelector('.arrow');
    dropdown.classList.toggle('hidden');
    arrow.classList.toggle('arrow-down');

  }

// Function to set default values
function setDefaultValues() {
    // Set default values for the input fields
    document.getElementById('titleInput').value = 'Title';
    document.getElementById('messageInput').value = 'Message';
    document.getElementById('subTextInput').value = 'Subtext';
}

// Call the function when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', setDefaultValues);




let selectedSizeButton = null; // Variable to keep track of the selected button
let printsize = "size24x18";

  function setSize(size, button) {
    // Update the hidden input with the selected size value (size24x18 or size18x12)
    document.getElementById('selectedSize').value = size;
    printsize=size;
    // If a button was already selected, remove the special border class
    if (selectedSizeButton) {
      selectedSizeButton.classList.remove('border-[#cca385]', 'border-4');
    }

    // Add the special border to the newly selected button
    button.classList.add('border-[#cca385]', 'border-4');

    // Keep track of the selected button
    selectedSizeButton = button;
  }


  function removeLocation(element) {
    const locationsContainer = document.getElementById('locationsContainer');
    const locationRows = locationsContainer.querySelectorAll('div');

    const indexToRemove = Array.from(locationRows).indexOf(element.parentElement);

    if (locationRows.length > 1) {
        // Remove the corresponding marker from the map
        if (markers[indexToRemove]) {
            markers[indexToRemove].remove(); // Remove marker from the map
            markers.splice(indexToRemove, 1); // Remove marker from the markers array
        }

        // Remove the point from GeoJSON data
        geojsonData.features.splice(indexToRemove, 1); // Remove the feature from the GeoJSON

        // Update the GeoJSON source on the map
        if (map.getSource('markers')) {
            map.getSource('markers').setData(geojsonData); // Refresh the source data with the updated GeoJSON
        }

        // Remove the location container from the DOM
        element.parentElement.remove();
        updateIndexes(); // Update the index numbers for the remaining locations
    } else if (locationRows.length === 1) {
        // Clear the last remaining container, but don't remove it
        const inputField = locationRows[0].querySelector('input');
        inputField.value = ''; // Clear the input field

        // Remove the marker if it exists
        if (markers[0]) {
            markers[0].remove(); // Remove marker from the map
            markers = []; // Clear the markers array since no markers are left
        }

        // Clear stored coordinates from the dataset
        locationRows[0].removeAttribute('data-lat');
        locationRows[0].removeAttribute('data-lng');

        // Clear the GeoJSON features array
        geojsonData.features = [];

        // Update the GeoJSON source on the map
        if (map.getSource('markers')) {
            map.getSource('markers').setData(geojsonData); // Refresh the source data with the cleared GeoJSON
        }
    }

    // Remove the route line if it exists
    if (map.getSource('route')) {
        map.removeLayer('route');
        map.removeSource('route');
    }

    // Recalculate the route only if there are enough remaining points
    const remainingCoordinates = Array.from(document.querySelectorAll('#locationsContainer > div'))
        .filter(row => row.dataset.lat && row.dataset.lng);

    if (remainingCoordinates.length >= 2) {
        calculateRoute();
    }

    // Update the canvas text after location removal
    updateCityNames();
}

// Function to update indexes after adding/removing locations
function updateIndexes() {
    const locationRows = document.querySelectorAll('#locationsContainer > div');
    locationRows.forEach((row, index) => {
        row.querySelector('.dropdown-text').textContent = `${index + 1}.`; // Update the index number
    });
}

        
    // Function to add a new location input
    function addLocation() {
    const locationsContainer = document.getElementById('locationsContainer');
    const locationCount = locationsContainer.querySelectorAll('div').length + 1;

    const newLocation = document.createElement('div');
    newLocation.className = 'flex items-center space-x-2';

    newLocation.innerHTML = `
        <span class="dropdown-text">${locationCount}.</span>
        <input type="text" placeholder="Enter City's name" class="border p-2 rounded w-full"> 
        <span class="remove-btn" onclick="removeLocation(this)">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-black cursor-pointer" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </span>
    `;

    locationsContainer.appendChild(newLocation);
    updateIndexes();

    // Add event listener for the new input field
    const newInputField = newLocation.querySelector('input');
    newInputField.addEventListener('input', updateCityNames); // Attach listener here

    // Scroll to the bottom of the container
    locationsContainer.scrollTop = locationsContainer.scrollHeight;
}


addLocation();

  let currentRouteData = null; // To store route data

  function selectTheme(theme) {
    
    if(theme==selectedTheme){return};
    selectedTheme = theme; // Update the global theme selection
    
    // Save the current route data (if it exists) before changing the theme
    if (map.getSource('route')) {
        currentRouteData = map.getSource('route')._data; // Save the current route GeoJSON data
    }

    // Update map style based on the selected theme
    const styles = {
        blue: 'mapbox://styles/talhawaqqas14/cm1s96dl200yw01qvet4c70x3',
        green: 'mapbox://styles/talhawaqqas14/cm2cph1pv00ts01peb9h22o6p',
        red: 'mapbox://styles/talhawaqqas14/cm2csq97700uz01pbepp64hmd',
        yellow: 'mapbox://styles/talhawaqqas14/cm2cs1cku00pf01pic3sq8nsq',
        purple: 'mapbox://styles/talhawaqqas14/cm2csdiwr00yn01qvcx8d3nrc',
        orange: 'mapbox://styles/talhawaqqas14/cm2csmkhm00ux01pbfkol7618',
        pink: 'mapbox://styles/talhawaqqas14/clv3x1c2t00f601qp5mzd3npx',
        gray: 'mapbox://styles/talhawaqqas14/cm2axer5n00p101pge4b9f4mz'
    };

    if (styles[theme]) {
        map.setStyle(styles[theme]); // Change the map style
    }

    map.on('style.load', () => {
        // Re-add the route to the map after the style is reloaded
        if (currentRouteData) {
            map.addSource('route', {
                type: 'geojson',
                data: currentRouteData // Use the stored route data
            });

            map.addLayer({
                id: 'route',
                type: 'line',
                source: 'route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': routeColors[selectedTheme], // Dynamic route color based on theme
                    'line-width': 4
                }
            });
        }

        // Re-add the circle layer to display the markers
        if (!map.getSource('markers')) {
            map.addSource('markers', {
                type: 'geojson',
                data: geojsonData // Initially empty or your existing data
            });
        }

        if (!map.getLayer('circle-markers')) {
            map.addLayer({
                id: 'circle-markers',
                type: 'circle',
                source: 'markers',
                paint: {
                    'circle-radius': 6, // Size of the circle
                    'circle-color': '#ffffff', // White background
                    'circle-stroke-color': themeColors[selectedTheme], // Border color from theme
                    'circle-stroke-width': 2, // Border width
                }
            });
        }
    });
    drawCityNamesOnCanvas();
    // Update UI: Remove selected class from all containers
    const containers = document.querySelectorAll('.theme-container');
    containers.forEach(container => {
        container.classList.remove('border-[#cca385]', 'border-4');
    });

    // Add selected class to the clicked container
    const selectedContainer = document.querySelector(`.theme-container[onclick*="${theme}"]`);
    selectedContainer.classList.add('border-[#cca385]', 'border-4');
}



  function performGeocoding(query) {
    if (!query) {
      document.getElementById('geocoder-results').classList.add('hidden');
      return;
    }
  

    const geocodingUrl = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${mapboxgl.accessToken}`;
  
    fetch(geocodingUrl)
      .then(response => response.json())
      .then(data => {
        const resultsContainer = document.getElementById('geocoder-results');
        resultsContainer.innerHTML = ''; // Clear previous results
        data.features.forEach(feature => {
          const placeName = feature.place_name;
          const coord = feature.geometry.coordinates;
  
          const resultItem = document.createElement('div');
          resultItem.className = 'p-2 hover:bg-[#cca385] cursor-pointer';
          resultItem.textContent = placeName;
          resultItem.onclick = () => {
            updateLatestLocation(placeName, coord); // Update the latest location
            resultsContainer.classList.add('hidden'); // Hide the results after selection
          };
          resultsContainer.appendChild(resultItem);
        });
        resultsContainer.classList.remove('hidden');
      })
      .catch(error => {
        console.error('Error with geocoding:', error);
      });
  }
  
  
  
  function updateLatestLocation(placeName, coord) {
    const locationsContainer = document.getElementById('locationsContainer');
    const locationRows = locationsContainer.querySelectorAll('div');

    if (locationRows.length === 0) {
        alert("No location input available. Please add a location first.");
        return;
    }

    // Find the last updated location input (this will be the container being modified)
    const latestLocation = locationRows[locationRows.length - 1];
    const inputField = latestLocation.querySelector('input');

    // Get the index of the current container to track the marker
    const locationIndex = Array.from(locationRows).indexOf(latestLocation);

    // Remove the existing marker for this location if it exists
    if (markers[locationIndex]) {
        markers[locationIndex].remove(); // Remove the previous marker from the map
    }

    // Update the input field with the new place name
    inputField.value = placeName;

    // Store lat/lng in the latest location dataset
    latestLocation.dataset.lat = coord[1]; // Store latitude
    latestLocation.dataset.lng = coord[0]; // Store longitude

    // Add the new marker to the map
    addPointToMap(coord, placeName, locationIndex);

    // Trigger the city name update on the canvas
    updateCityNames();  
}

  
  
  let markers = []; // Array to store map markers
  
  let routeColors = {
  blue: '#566d71',   // Blue theme route color
  green: '#28a745',  // Green theme route color (added for green)
  red: '#ff4c4c',    // Red theme route color
  yellow: '#ffc107', // Yellow theme route color
  purple: '#6f42c1', // Purple theme route color
  orange: '#fd7e14', // Orange theme route color
  pink: '#e83e8c',   // Pink theme route color
  gray: '#6c757d'    // Gray theme route color
};


let themeColors = {
  blue: '#5b7373',   // Blue theme color
  green: '#28a745',  // Green theme color (added for green)
  red: '#ff4c4c',    // Red theme color
  yellow: '#ffc107', // Yellow theme color
  purple: '#6f42c1', // Purple theme color
  orange: '#fd7e14', // Orange theme color
  pink: '#e83e8c',   // Pink theme color
  gray: '#6c757d'    // Gray theme color
};

let selectedTheme = 'blue'; // Default theme

// Define an empty GeoJSON object to store the marker points
let geojsonData = {
    type: 'FeatureCollection',
    features: []
};

// Add a source and layer to the map for the markers
map.on('load', function () {
    // Add a GeoJSON source for markers if it doesn't exist already
    if (!map.getSource('markers')) {
        map.addSource('markers', {
            type: 'geojson',
            data: geojsonData // Initially empty
        });
    }

    // Add a circle layer to display the markers
    if (!map.getLayer('circle-markers')) {
        map.addLayer({
            id: 'circle-markers',
            type: 'circle',
            source: 'markers',
            paint: {
                'circle-radius': 6 , // Size of the circle
                'circle-color': '#ffffff', // White background
                'circle-stroke-color': themeColors[selectedTheme], // Border color from theme
                'circle-stroke-width': 2, // Border width
                
            }
        });
    }
});

// Function to add a point to the GeoJSON source
function addPointToMap(coordinates, placeName, index) {
    // Create a new feature for the GeoJSON data
    const newFeature = {
        type: 'Feature',
        geometry: {
            type: 'Point',
            coordinates: coordinates // The coordinates of the point
        },
        properties: {
            description: placeName, // Add place name for popups or other use
            index: index // Add index to track specific markers
        }
    };

    // Replace the feature in the geojsonData or add a new one if it doesn't exist
    if (geojsonData.features[index]) {
        geojsonData.features[index] = newFeature; // Replace the existing feature
    } else {
        geojsonData.features.push(newFeature); // Add a new feature
    }

    // Update the GeoJSON source data on the map
    map.getSource('markers').setData(geojsonData);

    // Fly to the new marker location
    map.flyTo({
        center: coordinates,
        essential: true,
        zoom: 14
    });
}

// Optional: Add a popup when clicking on markers in the circle layer
map.on('click', 'circle-markers', function (e) {
    const coordinates = e.features[0].geometry.coordinates.slice();
    const description = e.features[0].properties.description;

    // Ensure the map properly pans for popups
    new mapboxgl.Popup()
        .setLngLat(coordinates)
        .setHTML(`<strong>${description}</strong>`)
        .addTo(map);
});

// Optional: Change the cursor when hovering over markers
map.on('mouseenter', 'circle-markers', function () {
    map.getCanvas().style.cursor = 'pointer';
});

map.on('mouseleave', 'circle-markers', function () {
    map.getCanvas().style.cursor = '';
});

  function calculateRoute() {
    const coordinates = [];
    document.querySelectorAll('#locationsContainer > div').forEach(location => {
      const lat = location.dataset.lat;
      const lng = location.dataset.lng;
      if (lat && lng) {
        coordinates.push([lng, lat]); // Coordinates are stored as [lng, lat]
      }
    });
  
    if (coordinates.length < 2) {
      alert("Please enter at least two valid locations.");
      return;
    }
  
    const query = coordinates.map(c => `${c[0]},${c[1]}`).join(';');
    const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${query}?geometries=geojson&access_token=${mapboxgl.accessToken}`;
  
    fetch(url)
      .then(response => response.json())
      .then(data => {
        const route = data.routes[0].geometry;
        displayRouteOnMap(route);
      })
      .catch(error => {
        console.error('Error fetching route:', error);
        alert("Unable to calculate the route. Please try again.");
      });
  }
  
  function displayRouteOnMap(route) {
    // Remove the existing route layer and source if it exists
    if (map.getSource('route')) {
        map.removeLayer('route');
        map.removeSource('route');
    }

    // Add the new route source
    map.addSource('route', {
        type: 'geojson',
        data: {
            type: 'Feature',
            properties: {},
            geometry: route
        }
    });

    // Add the route layer
    map.addLayer({
        id: 'route',
        type: 'line',
        source: 'route',
        layout: {
            'line-join': 'round',
            'line-cap': 'round'
        },
        paint: {
            'line-color': routeColors[selectedTheme], // Dynamic route color based on theme
            'line-width': 4
        }
    }, 'circle-markers'); // Add the route layer below the markers layer

    // Fit the map bounds to the route
    const bounds = new mapboxgl.LngLatBounds();
    route.coordinates.forEach(coord => {
        bounds.extend(coord);
    });
    map.fitBounds(bounds, { padding: 50 });
}

// Get the canvas element and context
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

// City names display toggle
let displayCityNames = true;

// Adjust the canvas size dynamically if needed
function resizeCanvas() {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // Redraw the city names whenever the canvas size changes
    if (displayCityNames) {
        drawCityNamesOnCanvas();
    }
}

// Call resizeCanvas on load and window resize
window.addEventListener('load', resizeCanvas);
window.addEventListener('resize', resizeCanvas);


let printtextcolor;

// Initialize global variables
let alignmentOption = 'right';
let fontStyleOption = 'normal';
let fontFamilyOption = 'Arial';




function printtext(ctx, canvasWidth, canvasHeight) {
    if (displayCityNames === false) { return; }

    // Get all location input fields
    const locationRows = document.querySelectorAll('#locationsContainer > div');
    const textColor = printtextcolor; // Get color based on selected theme

    // Scaling factors based on the original dimensions (7200x5400)
    const widthScale = canvasWidth / 7200;
    const heightScale = canvasHeight / 5400;

    // Adjusted font sizes and line heights based on scaling factors for city names
    const fontSize = 140 * heightScale; // Adjust font size relative to canvas height
    const lineHeight = 180 * heightScale; // Adjust line height relative to canvas height

    ctx.fillStyle = textColor; // Set text color
    ctx.font = `${fontSize}px Arial`; // Keep font fixed for city names
    ctx.textAlign = 'left'; // Fix alignment to the left for city names
    ctx.textBaseline = 'alphabetic'; // Standard text baseline for city names

    // Start drawing city names from the bottom left of the canvas (scaled for any canvas size)
    const startY = canvasHeight - 200 * heightScale; // Adjust Y starting point relative to canvas height
    const startX = 200 * widthScale; // Fixed X starting point for city names

    // Draw city names from the bottom up
    locationRows.forEach((row, index) => {
        const inputField = row.querySelector('input');
        const cityName = inputField.value.trim() || `City ${index + 1}`; // Default to "City X" if empty

        const positionY = startY - (locationRows.length - 1 - index) * lineHeight; // Calculate Y position from bottom up
        ctx.fillText(`${index + 1}. ${cityName}`, startX, positionY); // Draw city name text
    });

    // Get user input for title, message, and subtext
    const title = titleInput.value.trim() || ''; // Default to 'Title' if empty
    const message = messageInput.value.trim() || ''; // Default to 'Message' if empty
    const subText = subTextInput.value.trim() || ''; // Default to 'Subtext' if empty

    // Adjusted font sizes for title, message, and subtext
    const titleFontSize = 220 * heightScale;
    const messageFontSize = 180 * heightScale;
    const subTextFontSize = 140 * heightScale;

    // Set font, style, and alignment for title, message, and subtext
    const fontStyle = fontStyleOption || 'normal'; // Use global font style option
    const fontFamily = fontFamilyOption || 'Arial'; // Use global font family option
    const alignment = alignmentOption || 'right'; // Use global alignment option (default to right)

    ctx.fillStyle = textColor; // Set the fill color to theme color
    ctx.textAlign = alignment; // Apply user-selected alignment for title, message, subtext
    ctx.textBaseline = 'top'; // Align text to the top

    // Adjusted position for text at the top-right corner
    const margin = 200 * widthScale; // Adjust margin relative to canvas width
    const titleX = alignment === 'left' ? margin 
                 : alignment === 'center' ? canvasWidth / 2 
                 : canvasWidth - margin;
    const titleY = margin;

    // Draw the title at the top-right
    ctx.font = `${fontStyle} bold ${titleFontSize}px ${fontFamily}`; // Title font with user-selected options
    ctx.fillText(title, titleX, titleY);

    // Draw the message below the title
    ctx.font = `${fontStyle} ${messageFontSize}px ${fontFamily}`; // Message font with user-selected options
    const messageY = titleY + titleFontSize + 60 * heightScale; // Adjust message Y position
    ctx.fillText(message, titleX, messageY);

    // Draw the subtext below the message
    ctx.font = `${fontStyle} ${subTextFontSize}px ${fontFamily}`; // Subtext font with user-selected options
    const subTextY = messageY + messageFontSize + 60 * heightScale; // Adjust subtext Y position
    ctx.fillText(subText, titleX, subTextY);
}


// Get references to the text input fields
const titleInput = document.getElementById('titleInput');
const messageInput = document.getElementById('messageInput');
const subTextInput = document.getElementById('subTextInput');


// Event listeners to update the canvas as the user types
titleInput.addEventListener('input', drawCityNamesOnCanvas);
messageInput.addEventListener('input', drawCityNamesOnCanvas);
subTextInput.addEventListener('input', drawCityNamesOnCanvas);



// Functions to update each option based on user input
function updateAlignmentOption(value) {
  alignmentOption = value;
  drawCityNamesOnCanvas(); // Redraw to apply changes
}

function updateFontStyleOption(value) {
  fontStyleOption = value;
  drawCityNamesOnCanvas(); // Redraw to apply changes
}

function updateFontFamilyOption(value) {
  fontFamilyOption = value;
  drawCityNamesOnCanvas(); // Redraw to apply changes
}

function drawCityNamesOnCanvas(textColor = themeColors[selectedTheme]) {
  printtextcolor = textColor;

  if (displayCityNames == false) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous drawings

  const fontSize = 14; // Set the font size for city names
  const lineHeight = 20; // Line height between text entries
  ctx.fillStyle = textColor; // Set text color
  ctx.font = `${fontSize}px ${fontFamilyOption}`; // Set font size and family for city names

  // Start drawing city names from the bottom left of the canvas
  const startY = canvas.height - 20; // Position 20px from the bottom of the canvas
  const startX = 20; // Position 20px from the left edge of the canvas

  // Ensure text alignment is set to 'left' for the city names
  ctx.textAlign = 'left'; // Set text alignment to left for city names
  ctx.textBaseline = 'alphabetic'; // Standard text baseline for city names

  // Draw city names from the bottom up
  const locationRows = document.querySelectorAll('#locationsContainer > div');
  locationRows.forEach((row, index) => {
    const inputField = row.querySelector('input');
    const cityName = inputField.value.trim() || `City ${index + 1}`; // Default to "City X" if empty

    const positionY = startY - (locationRows.length - 1 - index) * lineHeight; // Calculate Y position from bottom up

    // Draw the city name text at the calculated position
    ctx.fillText(`${index + 1}. ${cityName}`, startX, positionY);
  });

  // Get user input for title, message, and subtext
  const title = titleInput.value.trim() 
  const message = messageInput.value.trim() 
  const subText = subTextInput.value.trim() 

  // Set text properties for the title, message, and subtext
  const titleFontSize = 24; // Title font size
  const messageFontSize = 18; // Message font size
  const subTextFontSize = 14; // Subtext font size

  // Set font and alignment for title, message, and subtext
  ctx.fillStyle = textColor; // Set the fill color to theme color
  ctx.textAlign = alignmentOption; // Set alignment
  ctx.textBaseline = 'top'; // Align text to the top

  // Position for text at the top based on alignment
  const margin = 20; // Margin from the edges
  let titleX;
  if (alignmentOption === 'left') {
    titleX = margin;
  } else if (alignmentOption === 'center') {
    titleX = canvas.width / 2;
  } else { // default to 'right'
    titleX = canvas.width - margin;
  }
  const titleY = margin;

  // Draw the title with selected font style and family
  ctx.font = `${fontStyleOption} ${titleFontSize}px ${fontFamilyOption}`;
  ctx.fillText(title, titleX, titleY);

  // Draw the message below the title
  ctx.font = `${fontStyleOption} ${messageFontSize}px ${fontFamilyOption}`;
  const messageY = titleY + titleFontSize + 10; // Position message below title
  ctx.fillText(message, titleX, messageY);

  // Draw the subtext below the message
  ctx.font = `${fontStyleOption} ${subTextFontSize}px ${fontFamilyOption}`;
  const subTextY = messageY + messageFontSize + 10; // Position subtext below message
  ctx.fillText(subText, titleX, subTextY);
}


// Function to update city names on canvas when input changes
function updateCityNames() {
    drawCityNamesOnCanvas(); // Directly call the drawing function
}




// Toggle visibility of city names
document.getElementById('toggleCityNames').addEventListener('click', () => {
    displayCityNames = !displayCityNames;
    if (displayCityNames) {
        drawCityNamesOnCanvas(); // Redraw city names if they're being displayed
    } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas if not displaying
    }
});



function updateLandColor(color) {

    const landLayerId = 'land';
    map.setPaintProperty(landLayerId, 'background-color', color);
}

function updateWaterColor(color) {

    const waterLayerId = 'water'; // Adjust according to your layer ID
    map.setPaintProperty(waterLayerId, 'fill-color', color);
}

function updateRouteColor(color){
  map.setPaintProperty('route', 'line-color', color);
}

function updateTextColor(color){
drawCityNamesOnCanvas(color);
}
function updateMarkerColor(color){
  map.setPaintProperty('circle-markers', 'circle-stroke-color', color);
}

document.getElementById('generate-btn').addEventListener('click', generateMap);

function generateMap() {
        'use strict';
       

        // Get user-defined values for width, height, and DPI
        let width = Number(document.getElementById('widthInput').value);  // User input for width
        let height = Number(document.getElementById('heightInput').value);  // User input for height
        const dpi = Number(document.getElementById('dpiInput').value);  // User input for DPI
        const format = document.getElementById('outputOptions').value === 'png' ? 'png' : 'pdf';  // Output format


        if (format === 'pdf') {
      if (printsize === 'size24x18') {
        width = 4.32;
        height = 3.24;
      } else if (printsize === 'size18x12') {
        width = 3.24;
        height = 2.24;
      }
    } else if (format === 'png') { map.setPaintProperty('circle-markers', 'circle-radius', 20);
        map.setPaintProperty('circle-markers', 'circle-stroke-width',5);
        map.setPaintProperty('route', 'line-width', 9);
      if (printsize === 'size24x18') {
        width = 8;
        height = 6;
      } else if (printsize === 'size18x12') {
        width = 6;
        height = 4;
      }
    }



        if (width <= 0 || height <= 0 || dpi <= 0) {
            alert("Width, height, and DPI must be positive numbers!");
            return;
        }

        // Calculate the required pixel dimensions based on DPI
        const pixelWidth = width * dpi;
        const pixelHeight = height * dpi;

        
        // Get current map state
        const zoom = map.getZoom();
        const center = map.getCenter();
        const bearing = map.getBearing();
        const pitch = map.getPitch();
        const style = map.getStyle();


        map.setPaintProperty('circle-markers', 'circle-radius', 6);
        map.setPaintProperty('circle-markers', 'circle-stroke-width', 2);
        map.setPaintProperty('route', 'line-width', 4);

        // Create the high-resolution map
        createPrintMap(pixelWidth, pixelHeight, dpi, format, zoom, center, bearing, pitch, style);
    }
    function createPrintMap(pixelWidth, pixelHeight, dpi, format, zoom, center, bearing, pitch, style) {
    'use strict';

    // Adjust the devicePixelRatio for high-resolution rendering
    const actualPixelRatio = window.devicePixelRatio;
    Object.defineProperty(window, 'devicePixelRatio', {
        get: function () { return dpi / 96; }
    });

    // Calculate the display container size (800x600 in your case)
    const containerWidth = 800;  // The width of the visible map container
    const containerHeight = 600;  // The height of the visible map container

    // Adjust the zoom level to compensate for the larger pixel dimensions
    const adjustedZoom = zoom + Math.log2(Math.min(pixelWidth / containerWidth, pixelHeight / containerHeight));

    // Create a hidden map container for rendering the high-resolution map
    const hiddenMapContainer = document.createElement('div');
    hiddenMapContainer.style.width = pixelWidth + 'px';
    hiddenMapContainer.style.height = pixelHeight + 'px';
    hiddenMapContainer.style.position = 'absolute';   // Prevent affecting page layout
    hiddenMapContainer.style.top = '-9999px';         // Move it out of the viewport
    hiddenMapContainer.style.left = '-9999px';        // Move it out of the viewport
    hiddenMapContainer.style.clip = 'rect(0, 0, 0, 0)';  // Ensure it's fully clipped
    document.body.appendChild(hiddenMapContainer);

    // Create a canvas element
    const hiddenCanvas = document.createElement('canvas');
    hiddenCanvas.width = pixelWidth * 3;
    hiddenCanvas.height = pixelHeight * 3;

    // Append the canvas to the hidden map container
    hiddenMapContainer.appendChild(hiddenCanvas);

    // Initialize a new Mapbox map in the hidden container
    const printMap = new mapboxgl.Map({
        container: hiddenMapContainer,
        center: center,
        zoom: adjustedZoom,  // Use the adjusted zoom level
        style: style,
        bearing: bearing,
        pitch: pitch,
        interactive: false,  // Disable interactions for the print map
        preserveDrawingBuffer: true  // Necessary for toBlob() or toDataURL()
    });

    // Wait until the map finishes loading before exporting
    printMap.once('load', function () {
    
            

        const hiddenCtx = hiddenCanvas.getContext('2d');

        // Get the original canvas
        const originalCanvas = printMap.getCanvas();

        // Draw the original canvas onto the hidden canvas
        hiddenCtx.drawImage(originalCanvas, 0, 0);


        // Optional: If you have text to print on the map
        printtext(hiddenCtx,hiddenCanvas.width,hiddenCanvas.height);

        if (format === 'png') {
            hiddenCanvas.toBlob(function (blob) {
                // Download the PNG
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'map.png';
                link.click();

                // Clean up
                URL.revokeObjectURL(link.href);
                hiddenCanvas.remove();
                document.body.removeChild(hiddenMapContainer);
                Object.defineProperty(window, 'devicePixelRatio', { get: function () { return actualPixelRatio; } });
            });
        } else {
            // PDF Generation using jsPDF
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: pixelWidth > pixelHeight ? 'l' : 'p',
                unit: 'pt',
                format: [pixelWidth, pixelHeight]
            });

            pdf.addImage(hiddenCanvas.toDataURL('image/png'), 'PNG', 0, 0, pixelWidth, pixelHeight);
            pdf.save('map.pdf');

            // Clean up
            hiddenCanvas.remove();
            document.body.removeChild(hiddenMapContainer);
            Object.defineProperty(window, 'devicePixelRatio', { get: function () { return actualPixelRatio; } });
        }
       
        printMap.remove();
        map.resize();
    });
}

        </script>
    </body>
    </html>
